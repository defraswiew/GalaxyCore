<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GalaxyCoreCommon</name>
    </assembly>
    <members>
        <member name="T:GalaxyCoreCommon.BaseMessage">
            <summary>
            Базовый класс сообщения
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.BaseMessage.Serialize">
            <summary>
            Упаковка сообщения в массив байт
            </summary>
            <returns>Массив байт</returns>
        </member>
        <member name="M:GalaxyCoreCommon.BaseMessage.Deserialize``1">
            <summary>
            Распаковка сообщения на основании внутреннего содержимого
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BaseMessage.Deserialize``1(System.Byte[])">
            <summary>
            Распаковка сообщения в новый экземпляр
            </summary>
            <typeparam name="T">Целевой тип</typeparam>
            <param name="data">Массив байт</param>
            <returns></returns>
        </member>
        <member name="T:GalaxyCoreCommon.BitGalaxy">
            <summary>
            Класс контейнера для битовой серриализации
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.BitGalaxy.data">
            <summary>
            Результирующий массив байт
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.BitGalaxy.LengthBits">
            <summary>
            Размер данных в битах
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.BitGalaxy.LengthBytes">
            <summary>
            Размер данных в байтах
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.BitGalaxy.position">
            <summary>
            Текущая позиция считывания в байтах
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.BitGalaxy.netBuffer">
            <summary>
            Основной буфер
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.#ctor">
            <summary>
            Стандартный конструктор
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.#ctor(System.Byte[])">
            <summary>
            Создать контейнер на основе имеющегося массива байт
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(System.Boolean)">
            <summary>
            Записать bool
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadBool">
            <summary>
            Прочитать bool
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(System.Byte)">
            <summary>
            Записать byte
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadByte">
            <summary>
            Прочитать byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(System.Byte[])">
            <summary>
            Записать массив byte
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadBytes(System.Int32)">
            <summary>
            Прочитать заданное число байт
            </summary>
            <param name="count">сколько байт читать</param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(System.Int16)">
            <summary>
            Записать short
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadShort">
            <summary>
            Прочитать short
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(System.UInt16)">
            <summary>
            Записать ushort
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadUshort">
            <summary>
            Прочитать ushort
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(System.Int32)">
            <summary>
            Записать Int
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadInt">
            <summary>
            Прочитать Int
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(System.UInt32)">
            <summary>
            Записать uint
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadUint">
            <summary>
            Прочитать uint
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(System.Int64)">
            <summary>
            Записать long
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadLong">
            <summary>
            Прочитать long
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(System.UInt64)">
            <summary>
            Записать ulong
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadUlong">
            <summary>
            Прочитать ulong
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(System.Single)">
            <summary>
            Записать float
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadFloat">
            <summary>
            Прочитать float
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(System.Double)">
            <summary>
            Записать double
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadDouble">
            <summary>
            Прочитать double
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(System.String)">
            <summary>
            Записать string
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadString">
            <summary>
            Прочитать string
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Записать GalaxyVector3
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadGalaxyVector3">
            <summary>
            Прочитать string
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.WriteValue(GalaxyCoreCommon.GalaxyQuaternion)">
            <summary>
            Записать GalaxyQuaternion
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:GalaxyCoreCommon.BitGalaxy.ReadGalaxyQuaternion">
            <summary>
            Прочитать string
            </summary>
            <returns></returns>
        </member>
        <member name="T:GalaxyCoreCommon.GalaxyDeliveryType">
            <summary>
            Способ доставки сообщения
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyDeliveryType.unreliable">
            <summary>
            Простое сообщение, без гарантии и сортировок, зато это самый быстрый и экономичный вариант. Такое сообщение подходит для данных имеющих низкое значение, к примеру перемещение персонажа
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyDeliveryType.unreliableNewest">
            <summary>
            Сообщение без гарантии доставки, однако с автоматическим сбросом более старых сообщений, Так же хорошо подходит для реализации перемещений
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyDeliveryType.reliable">
            <summary>
            Сообщение с гарантией доставки, но без соблюдения точной очередности, хорошо подходит для отправки важных данных, порядок приема и получения которых не важен
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyDeliveryType.reliableNewest">
            <summary>
            Сообщение с гарантией доставки,  однако с автоматическим сбросом более старых сообщений, подходит для важных данный, в случаях когда последнее полученое сообщение более важно чем предыдущее
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyDeliveryType.reliableOrdered">
            <summary>
            Сообщение с гарантией доставки и гарантией очередности. Сообщения будут гарантированно получены в том же порядке что и были отправленны, подходит для самых важных сообщений, скорость доставки которых не критично важна.
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.InternalMessageCodes">
            <summary>
            Внутренние коды сообщений
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.routeServer">
            <summary>
            Сообщение пользовательской логики отправленное в базовый серверный сепаратор
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.routeInstance">
            <summary>
            Сообщение пользовательской логики отправленное в текущий инстанс
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.routeNetEntity">
            <summary>
            Сообщение пользовательской логики отправленное сетевой сущности
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.routeNetEntityAnim">
            <summary>
            роутинг аниматора
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.routeClient">
            <summary>
            роутинг клиента
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.chat">
            <summary>
            Сообщение чата
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.instanceCreate">
            <summary>
            Создание нового инстанса
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.instanceList">
            <summary>
            Список инстансов
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.enterInInstance">
            <summary>
            Список инстансов
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.instanceSync">
            <summary>
            Синхронизация инстанса
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.updateClientsInInctance">
            <summary>
            Обновление информации о клиентах в инстансе
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.IncomingClient">
            <summary>
            Новый вошедший игрок
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.OutcomingClient">
            <summary>
            Клиент вышел
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.OutInstance">
            <summary>
            Выход из текущего инстанса
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.instanceChangeOwner">
            <summary>
            Смена владельца инстанса
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.netEntityInstantiate">
            <summary>
            Создание сетевого объекта
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.netEntitySyncTransform">
            <summary>
            Синхронизация сетевого трансформа
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.netEntityDestory">
            <summary>
            Удаление сетевой сущности
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.netEntityFrame">
            <summary>
            Фрейм сущностей
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.netEntityFrameTransform">
            <summary>
            трансформ фрейм
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.netEntityChangeOwner">
            <summary>
            Смена владельца объекта
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.netEntityGalaxyVars">
            <summary>
            Синхронизация переменных
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.InternalMessageCodes.error">
            <summary>
            Сообщение об ошибке
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.ErrorCodes">
            <summary>
            Встроенные коды ошибок
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.ErrorCodes.Сlient_is_already_in_the_instance">
            <summary>
            Клиент уже в инстансе
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.ErrorCodes.There_is_no_instance">
            <summary>
            Инстанса не существует
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.ErrorCodes.Instance_is_full">
            <summary>
            Нет свободных мест
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.ErrorCodes.Instance_password_not_correct">
            <summary>
            Не подходит пароль к инстансу
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.ChatMessageType">
            <summary>
            Тип сообщения
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.ChatMessageType.none">
            <summary>
            
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.ChatMessageType.all">
            <summary>
            всем
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.ChatMessageType.privateMessage">
            <summary>
            приватное
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.ChatMessageType.instance">
            <summary>
            в инстанс
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.ChatMessageType.group">
            <summary>
            групповое
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.GalaxyQuaternion">
            <summary>
            Сетевой кватернион
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyQuaternion.x">
            <summary>
            
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyQuaternion.y">
            <summary>
            
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyQuaternion.z">
            <summary>
            
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyQuaternion.w">
            <summary>
            
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.GalaxyVar">
            <summary>
            Synchronized variable attribute
            Атрибут для синхронизации переменной
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVar.sendChanges">
            <summary>
            Отправлять ли изменения переменной
            </summary>        
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVar.id">
            <summary>
            Ид переменной в рамках сущности
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVar.#ctor(System.Byte,System.Boolean)">
            <summary>
            Synchronized variable attribute
            </summary>
            <param name="id">unique variable id for the entity</param>
            <param name="sendChanges">Whether to send changes to a variable</param>
        </member>
        <member name="T:GalaxyCoreCommon.GalaxyVector3">
            <summary>
            Сетевая реализация Vector3
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVector3.x">
            <summary>
            Х координата
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVector3.y">
            <summary>
            Высота
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVector3.z">
            <summary>
            Z координата
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.Lerp(GalaxyCoreCommon.GalaxyVector3,GalaxyCoreCommon.GalaxyVector3,System.Single)">
            <summary>
            Линейная интерполяция вектора
            </summary>
            <param name="a">от куда</param>
            <param name="b">куда</param>
            <param name="t">время</param>
            <returns></returns>
        </member>
        <member name="P:GalaxyCoreCommon.GalaxyVector3.Item(System.Int32)">
            <summary>
            Доступ по индексу
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.Equals(GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.Distance(GalaxyCoreCommon.GalaxyVector3,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Расчет дистанции (с извлечением из корня)
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.op_Addition(GalaxyCoreCommon.GalaxyVector3,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            +
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.op_Subtraction(GalaxyCoreCommon.GalaxyVector3,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            -
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.op_UnaryNegation(GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            -
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.op_Multiply(GalaxyCoreCommon.GalaxyVector3,System.Single)">
            <summary>
            *
            </summary>
            <param name="a"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.op_Multiply(System.Single,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            *
            </summary>
            <param name="d"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.op_Division(GalaxyCoreCommon.GalaxyVector3,System.Single)">
            <summary>
            /
            </summary>
            <param name="a"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.ToString">
            <summary>
            Returns a nicely formatted string for this vector.
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVector3.ToString(System.String)">
            <summary>
            Returns a nicely formatted string for this vector.
            </summary>
            <param name="format">The format for each coordinate.</param>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVector3.Zero">
            <summary>
            Shorthand for writing Point(0, 0, 0).
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVector3.One">
            <summary>
            Shorthand for writing Point(1, 1, 1).
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVector3.Forward">
            <summary>
            Shorthand for writing Point(0, 0, 1).
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVector3.Back">
            <summary>
            Shorthand for writing Point(0, 0, -1).
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVector3.Up">
            <summary>
            Shorthand for writing Point(0, 1, 0).
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVector3.Down">
            <summary>
            Shorthand for writing Point(0, -1, 0).
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVector3.Left">
            <summary>
            Shorthand for writing Point(-1, 0, 0).
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.GalaxyVector3.Right">
            <summary>
            Shorthand for writing Point(1, 0, 0).
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.GalaxyVersion">
            <summary>
            Версионность
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.GalaxyVersion.#ctor(System.Single,System.Int32,System.String)">
            <summary>
            конструктор
            </summary>
            <param name="major"></param>
            <param name="monor"></param>
            <param name="type"></param>
        </member>
        <member name="T:GalaxyCoreCommon.InstanceInfo">
            <summary>
            Simplified instance-specific data
            Упрощенные данные о конкретном инстансе
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InstanceInfo.name">
            <summary>
            Instance name
            Имя инстанса
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InstanceInfo.clients">
            <summary>
            Current number of clients
            Текущее число клиентов
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InstanceInfo.maxClients">
            <summary>
            Maximum clients
            Максимум клиентов
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InstanceInfo.id">
            <summary>
            Instance ID
            Ид инстанса
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InstanceInfo.frameRate">
            <summary>
            Frame rate
            Фреймрейт
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InstanceInfo.type">
            <summary>
            Instance type
            Тип инстанса
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InstanceInfo.customData">
            <summary>
            User data
            Пользовательские данные
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InstanceInfo.owner">
            <summary>
            the owner of the room (he can also act as a virtual host)
            владелец комнаты (он же может работать как виртуальный host)
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InstanceInfo.password">
            <summary>
            is there a password to enter the room
            есть ли пароль на вход в комнату
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.InternalMessages.MessChat">
            <summary>
            Класс сообщения
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessChat.Type">
            <summary>
            Тип сообщения (роутинг)
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessChat.recipient">
            <summary>
            Ид получателя по роутингу
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessChat.text">
            <summary>
            текст сообщений
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessChat.sender">
            <summary>
            отправитель сообщения
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessChat.name">
            <summary>
            Имя для отображения
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.InternalMessages.MessChat.Clear">
            <summary>
            очистка сообщения
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.InternalMessages.MessClientBaseInfo">
            <summary>
            Базовая информация о клиенте
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessClientBaseInfo.id">
            <summary>
            Ид пользователя
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessClientBaseInfo.name">
            <summary>
            имя / ник пользователя
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessClientBaseInfo.data">
            <summary>
            Пользовательские данные
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.InternalMessages.MessInstanceCreate">
            <summary>
            Запрос создания инстанса
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessInstanceCreate.type">
            <summary>
            Тип инстанса
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessInstanceCreate.maxClients">
            <summary>
            Максимум игроков
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessInstanceCreate.name">
            <summary>
            Название инстанса
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessInstanceCreate.data">
            <summary>
            Пользовательские данные
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessInstanceCreate.password">
            <summary>
            Пароль на вход в инстанс (не обязателен)
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessInstanceCreate.visible">
            <summary>
            Видим ли инстанс в списке
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.InternalMessages.MessInstanceEnter">
            <summary>
            Сообщение запроса на вход в инстанс
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessInstanceEnter.id">
            <summary>
            Ид инсанса в который хотим войти
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessInstanceEnter.password">
            <summary>
            Пароль на вход если он есть
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessInstanceEnter.data">
            <summary>
            Пользовательские данные
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.InternalMessages.MessInstancesList">
            <summary>
            instance list message
            Сообщение с списком инстансов
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessInstancesList.instances">
            <summary>
            List instances
            Список инстансов
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.InternalMessages.MessInstanceSync">
            <summary>
            Сообщение синхронизации состояния сетевых сущностей
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessInstanceSync.netEntitys">
            <summary>
            Список сущностей
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.InternalMessages.MessNetEntityChangeOwner">
            <summary>
            Сообщение о смене владельца
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessNetEntityChangeOwner.netId">
            <summary>
            Ид сущности
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessNetEntityChangeOwner.owner">
            <summary>
            новый владелец
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.InternalMessages.MessNetEntityDestroy">
            <summary>
            Сообщение под удаление сетевой сущности
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessNetEntityDestroy.netId">
            <summary>
            Сетевой ид сущности
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.InternalMessages.MessNetEntityInstantiate">
            <summary>
            Сообщение создания новой сетевой сущности
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessNetEntityInstantiate.name">
            <summary>
            Имя для определения префаба если он нужен
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessNetEntityInstantiate.localId">
            <summary>
            локальный ид (необходим для корректной инициализации)
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessNetEntityInstantiate.netID">
            <summary>
            Сетевой индификатор сущности (назначается сервером)
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessNetEntityInstantiate.ownerClientId">
            <summary>
            Ид владельца объекта
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessNetEntityInstantiate.data">
            <summary>
            Пользовательские данные
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessNetEntityInstantiate.position">
            <summary>
            Положение сущности в пространстве (не обязательньный параметр)
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.InternalMessages.MessNetEntityInstantiate.rotation">
            <summary>
            Оринтация объекта в пространстве  (не обязательньный параметр)
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMap.name">
            <summary>
            Имя карты
            </summary>
        </member>
        <member name="P:GalaxyCoreCommon.Navigation.GalaxyMap.layers">
            <summary>
            Менеджер слоев
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMap.searchNodeDistance">
            <summary>
            Стандартная дистанция поиска нода по координатам
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMapLayer.id">
            <summary>
            Ид слоя
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMapLayer.name">
            <summary>
            Имя слоя
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMapLayer.isWalkable">
            <summary>
            Включать ли слой в расчет навигации
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMapLayer.heightWalkable">
            <summary>
            Допустимый перепад высот для прокладки пути
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMapLayer.transperent">
            <summary>
            нужно ли сканировать под этим слоем
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMapLayer.r">
            <summary>
            Красный
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMapLayer.g">
            <summary>
            Зеленый
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMapLayer.b">
            <summary>
            Голубой
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMapLayer.excludeGraph">
            <summary>
            Не включать в граф
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMapLayer.exscind">
            <summary>
            Вырезать из крафа все что попало внутрь объекта
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyMapLayer.cost">
            <summary>
            Множитель стоимости перемещения
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.Navigation.GalaxyMapLayerManager.GetById(System.Byte)">
            <summary>
            Получить слой по ид
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.Navigation.GalaxyMapLayerManager.CreateLayer">
            <summary>
            Запрос на создание нового слоя
            </summary>
            <returns>вернется ид нужного слоя</returns>
        </member>
        <member name="M:GalaxyCoreCommon.Navigation.GalaxyMapLayerManager.RemoveLayer(System.Byte)">
            <summary>
            Удалить слой по ид
            </summary>
            <param name="id"></param>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyNodeBase.layer">
            <summary>
            Слой нода
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyNodeBase.indexX">
            <summary>
            Индекс нода по X
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyNodeBase.indexZ">
            <summary>
            Индекс нода по Z
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyNodeBase.x">
            <summary>
            позиция по Х
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyNodeBase.y">
            <summary>
            Позиция по У
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyNodeBase.z">
            <summary>
            Позиция по Z
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyNodeFile.layer">
            <summary>
            Слой нода
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyNodeFile.indexX">
            <summary>
            Индекс нода по X
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyNodeFile.indexZ">
            <summary>
            Индекс нода по Z
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyNodeFile.x">
            <summary>
            позиция по Х
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyNodeFile.y">
            <summary>
            Позиция по У
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyNodeFile.z">
            <summary>
            Позиция по Z
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyPathAgent.layers">
            <summary>
            слои по которым будет простоен путь
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.Navigation.GalaxyPathAgent.maxLiftAngle">
            <summary>
            максимальный угол подьема
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.Navigation.IGalaxyPathResult.OnGalaxyPathResult(GalaxyCoreCommon.Navigation.Path)">
            <summary>
            Вернулся запрошенный маршрут
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:GalaxyCoreCommon.Navigation.Tools.CheckQuard(System.Int32)">
            <summary>
            Проверка корректности квадрата
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.Navigation.Tools.MergeNodes(System.Collections.Generic.List{GalaxyCoreCommon.Navigation.GalaxyNode},System.Single)">
            <summary>
            Объеденение части нодов в более большие
            </summary>
            <param name="nodes"></param>
            <param name="heightTrashold"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.Navigation.Tools.SearchQuad(GalaxyCoreCommon.Navigation.GalaxyNode,System.Collections.Generic.List{GalaxyCoreCommon.Navigation.GalaxyNode},System.Int32,System.Single)">
            <summary>
            Пытаемся вписать квадрат вокруг указанной ноды
            </summary>
            <param name="node">целевой нод</param>
            <param name="nodes">граф в котором будем работать</param>
            <param name="range">размер квадрата который нужно вписать</param>
            <param name="heightTrashold">допуск по высоте</param>
            <returns></returns>
        </member>
        <member name="T:GalaxyCoreCommon.NetVars">
            <summary>
            Variable Synchronization Kernel
            </summary>
        </member>
        <member name="E:GalaxyCoreCommon.NetVars.OnChangedValue">
            <summary>
            variable change event
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.NetVars.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.NetVars.Reg(System.Object)">
            <summary>
            Register a class to work with netVars
            Зарегистрировать класс для работы с netVars
            </summary>
            <param name="objects"></param>
        </member>
        <member name="M:GalaxyCoreCommon.NetVars.Update">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.NetVars.GetSendData">
            <summary>
            receiving data to send
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.NetVars.InData(GalaxyCoreCommon.InternalMessages.MessNetvars)">
            <summary>
            
            </summary>
            <param name="inMessage"></param>
        </member>
        <member name="T:GalaxyCoreCommon.PhysBake">
            <summary>
            Данные запекания коллизий
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.PhysBake.boxColliders">
            <summary>
            boxColliders
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.PhysBake.sphereColliders">
            <summary>
            sphereColliders
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.PhysBake.capsuleColliders">
            <summary>
            capsuleColliders
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.PhysBake.terrainColliders">
            <summary>
            terrainColliders
            </summary>
        </member>
        <member name="T:GalaxyCoreCommon.PhysBakeBoxCollider">
            <summary>
            Запеченный BoxCollider
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.Tools.GetNewID">
            <summary>
            Возвращяем ид пользователя
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.Tools.GetUnixTime">
            <summary>
            get the current time in unix format
            </summary>
            <returns></returns>
        </member>
        <member name="T:GalaxyCoreCommon.Tools.Crypto">
            <summary>
            Криптография
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.Tools.Crypto.GetMD5(System.String)">
            <summary>
            Возвращает MD5 строки
            </summary>
            <param name="input">Любой стринг</param>
            <returns></returns>  
        </member>
        <member name="M:GalaxyCoreCommon.Tools.Crypto.GetIntHash(System.String)">
            <summary>
            Генерирует INT-HASH из строки
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="F:GalaxyCoreCommon.TransformSerrializator.threshold">
            <summary>
            Порог изменений координат для отправки
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.TransformSerrializator.length">
            <summary>
            длинна полезной части буфера
            </summary>
        </member>
        <member name="F:GalaxyCoreCommon.TransformSerrializator.buffer">
            <summary>
            Временный буфер
            </summary>
        </member>
        <member name="M:GalaxyCoreCommon.TransformSerrializator.SetPosition(System.Single,System.Single,System.Single)">
            <summary>
            Установить координаты для серриализации
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:GalaxyCoreCommon.TransformSerrializator.SetPosition(GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Установить координаты для серриализации
            </summary>
            <param name="vector3"></param>
        </member>
        <member name="M:GalaxyCoreCommon.TransformSerrializator.Serrialize(Lidgren.Network.NetBuffer)">
            <summary>
            Сереаллизация изменений
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreCommon.TransformSerrializator.FullSerrialize(Lidgren.Network.NetBuffer)">
            <summary>
            Полная серриализация
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:Lidgren.Network.NetAESEncryption">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetAESEncryption.#ctor(Lidgren.Network.NetPeer)">
            <summary>
            
            </summary>
            <param name="peer"></param>
        </member>
        <member name="M:Lidgren.Network.NetAESEncryption.#ctor(Lidgren.Network.NetPeer,System.String)">
            <summary>
            
            </summary>
            <param name="peer"></param>
            <param name="key"></param>
        </member>
        <member name="M:Lidgren.Network.NetAESEncryption.#ctor(Lidgren.Network.NetPeer,System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="peer"></param>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="T:Lidgren.Network.NetBlockEncryptionBase">
            <summary>
            Base for a non-threadsafe encryption class
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBlockEncryptionBase.BlockSize">
            <summary>
            Block size in bytes for this cipher
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBlockEncryptionBase.#ctor(Lidgren.Network.NetPeer)">
            <summary>
            NetBlockEncryptionBase constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBlockEncryptionBase.Encrypt(Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Encrypt am outgoing message with this algorithm; no writing can be done to the message after encryption, or message will be corrupted
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBlockEncryptionBase.Decrypt(Lidgren.Network.NetIncomingMessage)">
            <summary>
            Decrypt an incoming message encrypted with corresponding Encrypt
            </summary>
            <param name="msg">message to decrypt</param>
            <returns>true if successful; false if failed</returns>
        </member>
        <member name="M:Lidgren.Network.NetBlockEncryptionBase.EncryptBlock(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Encrypt a block of bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBlockEncryptionBase.DecryptBlock(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Decrypt a block of bytes
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetEncryption">
            <summary>
            Interface for an encryption algorithm
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetEncryption.m_peer">
            <summary>
            NetPeer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetEncryption.#ctor(Lidgren.Network.NetPeer)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetEncryption.Encrypt(Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Encrypt an outgoing message in place
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetEncryption.Decrypt(Lidgren.Network.NetIncomingMessage)">
            <summary>
            Decrypt an incoming message in place
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetXorEncryption">
            <summary>
            Example class; not very good encryption
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetXorEncryption.#ctor(Lidgren.Network.NetPeer,System.Byte[])">
            <summary>
            NetXorEncryption constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetXorEncryption.#ctor(Lidgren.Network.NetPeer,System.String)">
            <summary>
            NetXorEncryption constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetXorEncryption.Encrypt(Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Encrypt an outgoing message
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetXorEncryption.Decrypt(Lidgren.Network.NetIncomingMessage)">
            <summary>
            Decrypt an incoming message
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetXtea">
            <summary>
            Methods to encrypt and decrypt data using the XTEA algorithm
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetXtea.BlockSize">
            <summary>
            Gets the block size for this cipher
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetXtea.#ctor(Lidgren.Network.NetPeer,System.Byte[],System.Int32)">
            <summary>
            16 byte key
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetXtea.#ctor(Lidgren.Network.NetPeer,System.Byte[])">
            <summary>
            16 byte key
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetXtea.#ctor(Lidgren.Network.NetPeer,System.String)">
            <summary>
            String to hash for key
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetXtea.EncryptBlock(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Encrypts a block of bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetXtea.DecryptBlock(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Decrypts a block of bytes
            </summary>
        </member>
        <member name="T:Lidgren.Network.NamespaceDoc">
            <summary>
            Lidgren Network Library
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetBigInteger">
            <summary>
            Big integer class based on BouncyCastle (http://www.bouncycastle.org) big integer code
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetBitVector">
            <summary>
            Fixed size vector of booleans
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBitVector.Capacity">
            <summary>
            Gets the number of bits/booleans stored in this vector
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.#ctor(System.Int32)">
            <summary>
            NetBitVector constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.IsEmpty">
            <summary>
            Returns true if all bits/booleans are set to zero/false
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.Count">
            <summary>
            Returns the number of bits/booleans set to one/true
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.RotateDown">
            <summary>
            Shift all bits one step down, cycling the first bit to the top
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.GetFirstSetIndex">
            <summary>
            Gets the first (lowest) index set to true
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.Get(System.Int32)">
            <summary>
            Gets the bit/bool at the specified index
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.Set(System.Int32,System.Boolean)">
            <summary>
            Sets or clears the bit/bool at the specified index
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBitVector.Bit(System.Int32)">
            <summary>
            Gets the bit/bool at the specified index
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.Clear">
            <summary>
            Sets all bits/booleans to zero/false
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitVector.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetBitWriter">
            <summary>
            Helper class for NetBuffer to write/read bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.ReadByte(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read 1-8 bits from a buffer into a byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.ReadBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Read several bytes from a buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteByte(System.Byte,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Write 0-8 bits of data to buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Write several whole bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.ReadUInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads an unsigned 16 bit integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.ReadUInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bits into an UInt32
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteUInt16(System.UInt16,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Writes an unsigned 16 bit integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteUInt32(System.UInt32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Writes the specified number of bits into a byte array
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteUInt64(System.UInt64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Writes the specified number of bits into a byte array
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.WriteVariableUInt32(System.Byte[],System.Int32,System.UInt32)">
            <summary>
            Write Base128 encoded variable sized unsigned integer
            </summary>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:Lidgren.Network.NetBitWriter.ReadVariableUInt32(System.Byte[],System.Int32@)">
            <summary>
            Reads a UInt32 written using WriteUnsignedVarInt(); will increment offset!
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetBuffer">
            <summary>
            Base class for NetIncomingMessage and NetOutgoingMessage
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetBuffer.c_overAllocateAmount">
            <summary>
            Number of bytes to overallocate for each message to avoid resizing
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBuffer.Data">
            <summary>
            Gets or sets the internal data buffer
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBuffer.LengthBytes">
            <summary>
            Gets or sets the length of the used portion of the buffer in bytes
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBuffer.LengthBits">
            <summary>
            Gets or sets the length of the used portion of the buffer in bits
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBuffer.Position">
            <summary>
            Gets or sets the read position in the buffer, in bits (not bytes)
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetBuffer.PositionInBytes">
            <summary>
            Gets the position in the buffer in bytes; note that the bits of the first returned byte may already have been read - check the Position property to make sure.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekDataBuffer">
            <summary>
            Gets the internal data buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekBoolean">
            <summary>
            Reads a 1-bit Boolean without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekByte">
            <summary>
            Reads a Byte without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekSByte">
            <summary>
            Reads an SByte without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekByte(System.Int32)">
            <summary>
            Reads the specified number of bits into a Byte without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekBytes(System.Int32)">
            <summary>
            Reads the specified number of bytes without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bytes without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekInt16">
            <summary>
            Reads an Int16 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekUInt16">
            <summary>
            Reads a UInt16 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekInt32">
            <summary>
            Reads an Int32 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekInt32(System.Int32)">
            <summary>
            Reads the specified number of bits into an Int32 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekUInt32">
            <summary>
            Reads a UInt32 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekUInt32(System.Int32)">
            <summary>
            Reads the specified number of bits into a UInt32 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekUInt64">
            <summary>
            Reads a UInt64 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekInt64">
            <summary>
            Reads an Int64 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekUInt64(System.Int32)">
            <summary>
            Reads the specified number of bits into an UInt64 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekInt64(System.Int32)">
            <summary>
            Reads the specified number of bits into an Int64 without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekFloat">
            <summary>
            Reads a 32-bit Single without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekSingle">
            <summary>
            Reads a 32-bit Single without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekDouble">
            <summary>
            Reads a 64-bit Double without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.PeekString">
            <summary>
            Reads a string without advancing the read pointer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadBoolean">
            <summary>
            Reads a boolean value (stored as a single bit) written using Write(bool)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadByte">
            <summary>
            Reads a byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadByte(System.Byte@)">
            <summary>
            Reads a byte and returns true or false for success
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadSByte">
            <summary>
            Reads a signed byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadByte(System.Int32)">
            <summary>
            Reads 1 to 8 bits into a byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadBytes(System.Int32)">
            <summary>
            Reads the specified number of bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadBytes(System.Int32,System.Byte[]@)">
            <summary>
            Reads the specified number of bytes and returns true for success
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bytes into a preallocated array
            </summary>
            <param name="into">The destination array</param>
            <param name="offset">The offset where to start writing in the destination array</param>
            <param name="numberOfBytes">The number of bytes to read</param>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadBits(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bits into a preallocated array
            </summary>
            <param name="into">The destination array</param>
            <param name="offset">The offset where to start writing in the destination array</param>
            <param name="numberOfBits">The number of bits to read</param>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadInt16">
            <summary>
            Reads a 16 bit signed integer written using Write(Int16)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUInt16">
            <summary>
            Reads a 16 bit unsigned integer written using Write(UInt16)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadInt32">
            <summary>
            Reads a 32 bit signed integer written using Write(Int32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadInt32(System.Int32@)">
            <summary>
            Reads a 32 bit signed integer written using Write(Int32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadInt32(System.Int32)">
            <summary>
            Reads a signed integer stored in 1 to 32 bits, written using Write(Int32, Int32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUInt32">
            <summary>
            Reads an 32 bit unsigned integer written using Write(UInt32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUInt32(System.UInt32@)">
            <summary>
            Reads an 32 bit unsigned integer written using Write(UInt32) and returns true for success
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUInt32(System.Int32)">
            <summary>
            Reads an unsigned integer stored in 1 to 32 bits, written using Write(UInt32, Int32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUInt64">
            <summary>
            Reads a 64 bit unsigned integer written using Write(UInt64)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadInt64">
            <summary>
            Reads a 64 bit signed integer written using Write(Int64)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUInt64(System.Int32)">
            <summary>
            Reads an unsigned integer stored in 1 to 64 bits, written using Write(UInt64, Int32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadInt64(System.Int32)">
            <summary>
            Reads a signed integer stored in 1 to 64 bits, written using Write(Int64, Int32)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadFloat">
            <summary>
            Reads a 32 bit floating point value written using Write(Single)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadSingle">
            <summary>
            Reads a 32 bit floating point value written using Write(Single)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadSingle(System.Single@)">
            <summary>
            Reads a 32 bit floating point value written using Write(Single)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadDouble">
            <summary>
            Reads a 64 bit floating point value written using Write(Double)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadVariableUInt32">
            <summary>
            Reads a variable sized UInt32 written using WriteVariableUInt32()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadVariableUInt32(System.UInt32@)">
            <summary>
            Reads a variable sized UInt32 written using WriteVariableUInt32() and returns true for success
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadVariableInt32">
            <summary>
            Reads a variable sized Int32 written using WriteVariableInt32()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadVariableInt64">
            <summary>
            Reads a variable sized Int64 written using WriteVariableInt64()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadVariableUInt64">
            <summary>
            Reads a variable sized UInt32 written using WriteVariableInt64()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadSignedSingle(System.Int32)">
            <summary>
            Reads a 32 bit floating point value written using WriteSignedSingle()
            </summary>
            <param name="numberOfBits">The number of bits used when writing the value</param>
            <returns>A floating point value larger or equal to -1 and smaller or equal to 1</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadUnitSingle(System.Int32)">
            <summary>
            Reads a 32 bit floating point value written using WriteUnitSingle()
            </summary>
            <param name="numberOfBits">The number of bits used when writing the value</param>
            <returns>A floating point value larger or equal to 0 and smaller or equal to 1</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadRangedSingle(System.Single,System.Single,System.Int32)">
            <summary>
            Reads a 32 bit floating point value written using WriteRangedSingle()
            </summary>
            <param name="min">The minimum value used when writing the value</param>
            <param name="max">The maximum value used when writing the value</param>
            <param name="numberOfBits">The number of bits used when writing the value</param>
            <returns>A floating point value larger or equal to MIN and smaller or equal to MAX</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadRangedInteger(System.Int32,System.Int32)">
            <summary>
            Reads a 32 bit integer value written using WriteRangedInteger()
            </summary>
            <param name="min">The minimum value used when writing the value</param>
            <param name="max">The maximum value used when writing the value</param>
            <returns>A signed integer value larger or equal to MIN and smaller or equal to MAX</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadRangedInteger(System.Int64,System.Int64)">
            <summary>
            Reads a 64 bit integer value written using WriteRangedInteger() (64 version)
            </summary>
            <param name="min">The minimum value used when writing the value</param>
            <param name="max">The maximum value used when writing the value</param>
            <returns>A signed integer value larger or equal to MIN and smaller or equal to MAX</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadString">
            <summary>
            Reads a string written using Write(string)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadString(System.String@)">
            <summary>
            Reads a string written using Write(string) and returns true for success
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadTime(Lidgren.Network.NetConnection,System.Boolean)">
            <summary>
            Reads a value, in local time comparable to NetTime.Now, written using WriteTime() for the connection supplied
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadIPEndPoint">
            <summary>
            Reads a stored IPv4 endpoint description
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.SkipPadBits">
            <summary>
            Pads data with enough bits to reach a full byte. Decreases cpu usage for subsequent byte writes.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadPadBits">
            <summary>
            Pads data with enough bits to reach a full byte. Decreases cpu usage for subsequent byte writes.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.SkipPadBits(System.Int32)">
            <summary>
            Pads data with the specified number of bits.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadAllFields(System.Object)">
            <summary>
            Reads all public and private declared instance fields of the object in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadAllFields(System.Object,System.Reflection.BindingFlags)">
            <summary>
            Reads all fields with the specified binding of the object in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadAllProperties(System.Object)">
            <summary>
            Reads all public and private declared instance fields of the object in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.ReadAllProperties(System.Object,System.Reflection.BindingFlags)">
            <summary>
            Reads all fields with the specified binding of the object in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.EnsureBufferSize(System.Int32)">
            <summary>
            Ensures the buffer can hold this number of bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.InternalEnsureBufferSize(System.Int32)">
            <summary>
            Ensures the buffer can hold this number of bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Boolean)">
            <summary>
            Writes a boolean value using 1 bit
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Byte)">
            <summary>
            Write a byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAt(System.Int32,System.Byte)">
            <summary>
            Writes a byte at a given offset in the buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.SByte)">
            <summary>
            Writes a signed byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Byte,System.Int32)">
            <summary>
            Writes 1 to 8 bits of a byte
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Byte[])">
            <summary>
            Writes all bytes in an array
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the specified number of bytes from an array
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.UInt16)">
            <summary>
            Writes an unsigned 16 bit integer
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAt(System.Int32,System.UInt16)">
            <summary>
            Writes a 16 bit unsigned integer at a given offset in the buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.UInt16,System.Int32)">
            <summary>
            Writes an unsigned integer using 1 to 16 bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Int16)">
            <summary>
            Writes a signed 16 bit integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAt(System.Int32,System.Int16)">
            <summary>
            Writes a 16 bit signed integer at a given offset in the buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Int32)">
            <summary>
            Writes a 32 bit signed integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAt(System.Int32,System.Int32)">
            <summary>
            Writes a 32 bit signed integer at a given offset in the buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.UInt32)">
            <summary>
            Writes a 32 bit unsigned integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAt(System.Int32,System.UInt32)">
            <summary>
            Writes a 32 bit unsigned integer at a given offset in the buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.UInt32,System.Int32)">
            <summary>
            Writes a 32 bit signed integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Int32,System.Int32)">
            <summary>
            Writes a signed integer using 1 to 32 bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.UInt64)">
            <summary>
            Writes a 64 bit unsigned integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAt(System.Int32,System.UInt64)">
            <summary>
            Writes a 64 bit unsigned integer at a given offset in the buffer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.UInt64,System.Int32)">
            <summary>
            Writes an unsigned integer using 1 to 64 bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Int64)">
            <summary>
            Writes a 64 bit signed integer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Int64,System.Int32)">
            <summary>
            Writes a signed integer using 1 to 64 bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Single)">
            <summary>
            Writes a 32 bit floating point value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Double)">
            <summary>
            Writes a 64 bit floating point value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteVariableUInt32(System.UInt32)">
            <summary>
            Write Base128 encoded variable sized unsigned integer of up to 32 bits
            </summary>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteVariableInt32(System.Int32)">
            <summary>
            Write Base128 encoded variable sized signed integer of up to 32 bits
            </summary>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteVariableInt64(System.Int64)">
            <summary>
            Write Base128 encoded variable sized signed integer of up to 64 bits
            </summary>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteVariableUInt64(System.UInt64)">
            <summary>
            Write Base128 encoded variable sized unsigned integer of up to 64 bits
            </summary>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteSignedSingle(System.Single,System.Int32)">
            <summary>
            Compress (lossy) a float in the range -1..1 using numberOfBits bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteUnitSingle(System.Single,System.Int32)">
            <summary>
            Compress (lossy) a float in the range 0..1 using numberOfBits bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteRangedSingle(System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Compress a float within a specified range using a certain number of bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteRangedInteger(System.Int32,System.Int32,System.Int32)">
            <summary>
            Writes an integer with the least amount of bits need for the specified range
            Returns number of bits written
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteRangedInteger(System.Int64,System.Int64,System.Int64)">
            <summary>
            Writes an integer with the least amount of bits need for the specified range
            Returns number of bits written
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.String)">
            <summary>
            Write a string
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(System.Net.IPEndPoint)">
            <summary>
            Writes an endpoint description
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteTime(System.Boolean)">
            <summary>
            Writes the current local time to a message; readable (and convertable to local time) by the remote host using ReadTime()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteTime(System.Double,System.Boolean)">
            <summary>
            Writes a local timestamp to a message; readable (and convertable to local time) by the remote host using ReadTime()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WritePadBits">
            <summary>
            Pads data with enough bits to reach a full byte. Decreases cpu usage for subsequent byte writes.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WritePadBits(System.Int32)">
            <summary>
            Pads data with the specified number of bits.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.Write(Lidgren.Network.NetBuffer)">
            <summary>
            Append all the bits of message to this message
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAllFields(System.Object)">
            <summary>
            Writes all public and private declared instance fields of the object in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAllFields(System.Object,System.Reflection.BindingFlags)">
            <summary>
            Writes all fields with specified binding in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAllProperties(System.Object)">
            <summary>
            Writes all public and private declared instance properties of the object in alphabetical order using reflection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetBuffer.WriteAllProperties(System.Object,System.Reflection.BindingFlags)">
            <summary>
            Writes all properties with specified binding in alphabetical order using reflection
            </summary>
        </member>
        <member name="T:Lidgren.Network.SingleUIntUnion">
            <summary>
            Utility struct for writing Singles
            </summary>
        </member>
        <member name="F:Lidgren.Network.SingleUIntUnion.SingleValue">
            <summary>
            Value as a 32 bit float
            </summary>
        </member>
        <member name="F:Lidgren.Network.SingleUIntUnion.UIntValue">
            <summary>
            Value as an unsigned 32 bit integer
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetClient">
            <summary>
            Specialized version of NetPeer used for a "client" connection. It does not accept any incoming connections and maintains a ServerConnection property
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetClient.ServerConnection">
            <summary>
            Gets the connection to the server, if any
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetClient.ConnectionStatus">
            <summary>
            Gets the connection status of the server connection (or NetConnectionStatus.Disconnected if no connection)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetClient.#ctor(Lidgren.Network.NetPeerConfiguration)">
            <summary>
            NetClient constructor
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:Lidgren.Network.NetClient.Connect(System.Net.IPEndPoint,Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Connect to a remote server
            </summary>
            <param name="remoteEndPoint">The remote endpoint to connect to</param>
            <param name="hailMessage">The hail message to pass</param>
            <returns>server connection, or null if already connected</returns>
        </member>
        <member name="M:Lidgren.Network.NetClient.Disconnect(System.String)">
            <summary>
            Disconnect from server
            </summary>
            <param name="byeMessage">reason for disconnect</param>
        </member>
        <member name="M:Lidgren.Network.NetClient.SendMessage(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetDeliveryMethod)">
            <summary>
            Sends message to server
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetClient.SendMessage(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetDeliveryMethod,System.Int32)">
            <summary>
            Sends message to server
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetClient.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetConnection">
            <summary>
            Represents a connection to a remote peer
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.Tag">
            <summary>
            Gets or sets the application defined object containing data about the connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.Peer">
            <summary>
            Gets the peer which holds this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.Status">
            <summary>
            Gets the current status of the connection (synced to the last status message read)
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.Statistics">
            <summary>
            Gets various statistics for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.RemoteEndPoint">
            <summary>
            Gets the remote endpoint for the connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.RemoteUniqueIdentifier">
            <summary>
            Gets the unique identifier of the remote NetPeer for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.LocalHailMessage">
            <summary>
            Gets the local hail message that was sent as part of the handshake
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.MutateEndPoint(System.Net.IPEndPoint)">
            <summary>
            Change the internal endpoint to this new one. Used when, during handshake, a switch in port is detected (due to NAT)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.SendMessage(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetDeliveryMethod,System.Int32)">
            <summary>
            Send a message to this remote connection
            </summary>
            <param name="msg">The message to send</param>
            <param name="method">How to deliver the message</param>
            <param name="sequenceChannel">Sequence channel within the delivery method</param>
        </member>
        <member name="M:Lidgren.Network.NetConnection.GetSendQueueInfo(Lidgren.Network.NetDeliveryMethod,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Zero windowSize indicates that the channel is not yet instantiated (used)
            Negative freeWindowSlots means this amount of messages are currently queued but delayed due to closed window
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetConnection.DelegateDisconnected">
            <summary>
            делегат дисконекта
            </summary>
        </member>
        <member name="E:Lidgren.Network.NetConnection.OnDisconnected">
            <summary>
            Событие вызываемое при дисконекте
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.RemoteHailMessage">
            <summary>
            The message that the remote part specified via Connect() or Approve() - can be null.
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.Approve">
            <summary>
            Approves this connection; sending a connection response to the remote host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.Approve(Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Approves this connection; sending a connection response to the remote host
            </summary>
            <param name="localHail">The local hail message that will be set as RemoteHailMessage on the remote host</param>
        </member>
        <member name="M:Lidgren.Network.NetConnection.Deny">
            <summary>
            Denies this connection; disconnecting it
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.Deny(System.String)">
            <summary>
            Denies this connection; disconnecting it
            </summary>
            <param name="reason">The stated reason for the disconnect, readable as a string in the StatusChanged message on the remote host</param>
        </member>
        <member name="M:Lidgren.Network.NetConnection.Disconnect(System.String)">
            <summary>
            Disconnect from the remote peer
            </summary>
            <param name="byeMessage">the message to send with the disconnect message</param>
        </member>
        <member name="P:Lidgren.Network.NetConnection.AverageRoundtripTime">
            <summary>
            Gets the current average roundtrip time in seconds
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.RemoteTimeOffset">
            <summary>
            Time offset between this peer and the remote peer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.GetLocalTime(System.Double)">
            <summary>
            Gets local time value comparable to NetTime.Now from a remote value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnection.GetRemoteTime(System.Double)">
            <summary>
            Gets the remote time value for a local time value produced by NetTime.Now
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnection.CurrentMTU">
            <summary>
            Gets the current MTU in bytes. If PeerConfiguration.AutoExpandMTU is false, this will be PeerConfiguration.MaximumTransmissionUnit.
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetConnectionStatistics">
            <summary>
            Statistics for a NetConnection instance
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.SentPackets">
            <summary>
            Gets the number of sent packets for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.ReceivedPackets">
            <summary>
            Gets the number of received packets for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.SentBytes">
            <summary>
            Gets the number of sent bytes for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.ReceivedBytes">
            <summary>
            Gets the number of received bytes for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.SentMessages">
            <summary>
            Gets the number of sent messages for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.ReceivedMessages">
            <summary>
            Gets the number of received messages for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.ResentMessages">
            <summary>
            Gets the number of resent reliable messages for this connection
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetConnectionStatistics.DroppedMessages">
            <summary>
            Gets the number of dropped messages for this connection
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetConnectionStatistics.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetConnectionStatus">
            <summary>
            Status for a NetConnection instance
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.None">
            <summary>
            No connection, or attempt, in place
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.InitiatedConnect">
            <summary>
            Connect has been sent; waiting for ConnectResponse
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.ReceivedInitiation">
            <summary>
            Connect was received, but ConnectResponse hasn't been sent yet
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.RespondedAwaitingApproval">
            <summary>
            Connect was received and ApprovalMessage released to the application; awaiting Approve() or Deny()
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.RespondedConnect">
            <summary>
            Connect was received and ConnectResponse has been sent; waiting for ConnectionEstablished
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.Connected">
            <summary>
            Connected
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.Disconnecting">
            <summary>
            In the process of disconnecting
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConnectionStatus.Disconnected">
            <summary>
            Disconnected
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetConstants">
            <summary>
            All the constants used when compiling the library
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConstants.NumSequencedChannels">
            <summary>
            Number of channels which needs a sequence number to work
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetConstants.NumReliableChannels">
            <summary>
            Number of reliable channels
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetDeliveryMethod">
            <summary>
            How the library deals with resends and handling of late messages
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetDeliveryMethod.Unknown">
            <summary>
            Indicates an error
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetDeliveryMethod.Unreliable">
            <summary>
            Unreliable, unordered delivery
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetDeliveryMethod.UnreliableSequenced">
            <summary>
            Unreliable delivery, but automatically dropping late messages
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetDeliveryMethod.ReliableUnordered">
            <summary>
            Reliable delivery, but unordered
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetDeliveryMethod.ReliableSequenced">
            <summary>
            Reliable delivery, except for late messages which are dropped
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetDeliveryMethod.ReliableOrdered">
            <summary>
            Reliable, ordered delivery
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetException">
            <summary>
            Exception thrown in the Lidgren Network Library
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetException.#ctor">
            <summary>
            NetException constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetException.#ctor(System.String)">
            <summary>
            NetException constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetException.#ctor(System.String,System.Exception)">
            <summary>
            NetException constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetException.Assert(System.Boolean,System.String)">
            <summary>
            Throws an exception, in DEBUG only, if first parameter is false
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetException.Assert(System.Boolean)">
            <summary>
            Throws an exception, in DEBUG only, if first parameter is false
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetIncomingMessage">
            <summary>
            Incoming message either sent from a remote peer or generated within the library
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetIncomingMessage.MessageType">
            <summary>
            Gets the type of this incoming message
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetIncomingMessage.DeliveryMethod">
            <summary>
            Gets the delivery method this message was sent with (if user data)
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetIncomingMessage.SequenceChannel">
            <summary>
            Gets the sequence channel this message was sent with (if user data)
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetIncomingMessage.SenderEndPoint">
            <summary>
            endpoint of sender, if any
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetIncomingMessage.SenderConnection">
            <summary>
            NetConnection of sender, if any
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetIncomingMessage.ReceiveTime">
            <summary>
            What local time the message was received from the network
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetIncomingMessage.Decrypt(Lidgren.Network.NetEncryption)">
            <summary>
            Decrypt a message
            </summary>
            <param name="encryption">The encryption algorithm used to encrypt the message</param>
            <returns>true on success</returns>
        </member>
        <member name="M:Lidgren.Network.NetIncomingMessage.ReadTime(System.Boolean)">
            <summary>
            Reads a value, in local time comparable to NetTime.Now, written using WriteTime()
            Must have a connected sender
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetIncomingMessage.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetIncomingMessageType">
            <summary>
            The type of a NetIncomingMessage
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.Error">
            <summary>
            Error; this value should never appear
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.StatusChanged">
            <summary>
            Status for a connection changed
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.UnconnectedData">
            <summary>
            Data sent using SendUnconnectedMessage
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.ConnectionApproval">
            <summary>
            Connection approval is needed
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.Data">
            <summary>
            Application data
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.Receipt">
            <summary>
            Receipt of delivery
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.DiscoveryRequest">
            <summary>
            Discovery request for a response
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.DiscoveryResponse">
            <summary>
            Discovery response to a request
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.VerboseDebugMessage">
            <summary>
            Verbose debug message
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.DebugMessage">
            <summary>
            Debug message
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.WarningMessage">
            <summary>
            Warning message
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.ErrorMessage">
            <summary>
            Error message
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.NatIntroductionSuccess">
            <summary>
            NAT introduction was successful
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetIncomingMessageType.ConnectionLatencyUpdated">
            <summary>
            A roundtrip was measured and NetConnection.AverageRoundtripTime was updated
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetPeer">
            <summary>
            Represents a local peer capable of holding zero, one or more connections to remote peers
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Introduce(System.Net.IPEndPoint,System.Net.IPEndPoint,System.Net.IPEndPoint,System.Net.IPEndPoint,System.String)">
            <summary>
            Send NetIntroduction to hostExternal and clientExternal; introducing client to host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.HandleNatIntroduction(System.Int32)">
            <summary>
            Called when host/client receives a NatIntroduction message from a master server
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.HandleNatPunch(System.Int32,System.Net.IPEndPoint)">
            <summary>
            Called when receiving a NatPunchMessage from a remote endpoint
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Status">
            <summary>
            Gets the NetPeerStatus of the NetPeer
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.MessageReceivedEvent">
            <summary>
            Signalling event which can be waited on to determine when a message is queued for reading.
            Note that there is no guarantee that after the event is signaled the blocked thread will 
            find the message in the queue. Other user created threads could be preempted and dequeue 
            the message before the waiting thread wakes up.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.UniqueIdentifier">
            <summary>
            Gets a unique identifier for this NetPeer based on Mac address and ip/port. Note! Not available until Start() has been called!
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Port">
            <summary>
            Gets the port number this NetPeer is listening and sending on, if Start() has been called
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.UPnP">
            <summary>
            Returns an UPnP object if enabled in the NetPeerConfiguration
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Tag">
            <summary>
            Gets or sets the application defined object containing data about the peer
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Connections">
            <summary>
            Gets a copy of the list of connections
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.ConnectionsCount">
            <summary>
            Gets the number of active connections
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Statistics">
            <summary>
            Statistics on this NetPeer since it was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Configuration">
            <summary>
            Gets the configuration used to instanciate this NetPeer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.#ctor(Lidgren.Network.NetPeerConfiguration)">
            <summary>
            NetPeer constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Start">
            <summary>
            Binds to socket and spawns the networking thread
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.GetConnection(System.Net.IPEndPoint)">
            <summary>
            Get the connection, if any, for a certain remote endpoint
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.WaitMessage(System.Int32)">
            <summary>
            Read a pending message from any connection, blocking up to maxMillis if needed
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.ReadMessage">
            <summary>
            Read a pending message from any connection, if any
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.ReadMessage(Lidgren.Network.NetIncomingMessage@)">
            <summary>
            Reads a pending message from any connection, if any.
            Returns true if message was read, otherwise false.
            </summary>
            <returns>True, if message was read.</returns>
        </member>
        <member name="M:Lidgren.Network.NetPeer.ReadMessages(System.Collections.Generic.IList{Lidgren.Network.NetIncomingMessage})">
            <summary>
            Read a pending message from any connection, if any
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Connect(System.String,System.Int32)">
            <summary>
            Create a connection to a remote endpoint
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Connect(System.String,System.Int32,Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Create a connection to a remote endpoint
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Connect(System.Net.IPEndPoint)">
            <summary>
            Create a connection to a remote endpoint
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Connect(System.Net.IPEndPoint,Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Create a connection to a remote endpoint
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.RawSend(System.Byte[],System.Int32,System.Int32,System.Net.IPEndPoint)">
            <summary>
            Send raw bytes; only used for debugging
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.ThrowOrLog(System.String)">
            <summary>
            In DEBUG, throws an exception, in RELEASE logs an error message
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Shutdown(System.String)">
            <summary>
            Disconnects all active connections and closes the socket
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.DiscoverLocalPeers(System.Int32)">
            <summary>
            Emit a discovery signal to all hosts on your subnet
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.DiscoverKnownPeer(System.String,System.Int32)">
            <summary>
            Emit a discovery signal to a single known host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.DiscoverKnownPeer(System.Net.IPEndPoint)">
            <summary>
            Emit a discovery signal to a single known host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendDiscoveryResponse(Lidgren.Network.NetOutgoingMessage,System.Net.IPEndPoint)">
            <summary>
            Send a discovery response message
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeer.Socket">
            <summary>
            Gets the socket, if Start() has been called
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.RegisterReceivedCallback(System.Threading.SendOrPostCallback,System.Threading.SynchronizationContext)">
            <summary>
            Call this to register a callback for when a new message arrives
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.UnregisterReceivedCallback(System.Threading.SendOrPostCallback)">
            <summary>
            Call this to unregister a callback, but remember to do it in the same synchronization context!
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.FlushSendQueue">
            <summary>
            If NetPeerConfiguration.AutoFlushSendQueue() is false; you need to call this to send all messages queued using SendMessage()
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.CreateMessage">
            <summary>
            Creates a new message for sending
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.CreateMessage(System.String)">
            <summary>
            Creates a new message for sending and writes the provided string to it
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.CreateMessage(System.Int32)">
            <summary>
            Creates a new message for sending
            </summary>
            <param name="initialCapacity">initial capacity in bytes</param>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Recycle(Lidgren.Network.NetIncomingMessage)">
            <summary>
            Recycles a NetIncomingMessage instance for reuse; taking pressure off the garbage collector
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.Recycle(System.Collections.Generic.IEnumerable{Lidgren.Network.NetIncomingMessage})">
            <summary>
            Recycles a list of NetIncomingMessage instances for reuse; taking pressure off the garbage collector
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.CreateIncomingMessage(Lidgren.Network.NetIncomingMessageType,System.String)">
            <summary>
            Creates an incoming message with the required capacity for releasing to the application
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendMessage(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetConnection,Lidgren.Network.NetDeliveryMethod)">
            <summary>
            Send a message to a specific connection
            </summary>
            <param name="msg">The message to send</param>
            <param name="recipient">The recipient connection</param>
            <param name="method">How to deliver the message</param>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendMessage(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetConnection,Lidgren.Network.NetDeliveryMethod,System.Int32)">
            <summary>
            Send a message to a specific connection
            </summary>
            <param name="msg">The message to send</param>
            <param name="recipient">The recipient connection</param>
            <param name="method">How to deliver the message</param>
            <param name="sequenceChannel">Sequence channel within the delivery method</param>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendMessage(Lidgren.Network.NetOutgoingMessage,System.Collections.Generic.IList{Lidgren.Network.NetConnection},Lidgren.Network.NetDeliveryMethod,System.Int32)">
            <summary>
            Send a message to a list of connections
            </summary>
            <param name="msg">The message to send</param>
            <param name="recipients">The list of recipients to send to</param>
            <param name="method">How to deliver the message</param>
            <param name="sequenceChannel">Sequence channel within the delivery method</param>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendUnconnectedMessage(Lidgren.Network.NetOutgoingMessage,System.String,System.Int32)">
            <summary>
            Send a message to an unconnected host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendUnconnectedMessage(Lidgren.Network.NetOutgoingMessage,System.Net.IPEndPoint)">
            <summary>
            Send a message to an unconnected host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendUnconnectedMessage(Lidgren.Network.NetOutgoingMessage,System.Collections.Generic.IList{System.Net.IPEndPoint})">
            <summary>
            Send a message to an unconnected host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeer.SendUnconnectedToSelf(Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Send a message to this exact same netpeer (loopback)
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetOutgoingMessage">
            <summary>
            Outgoing message used to send data to remote peer(s)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetOutgoingMessage.Encrypt(Lidgren.Network.NetEncryption)">
            <summary>
            Encrypt this message using the provided algorithm; no more writing can be done before sending it or the message will be corrupt!
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetOutgoingMessage.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetPeerConfiguration">
            <summary>
            Partly immutable after NetPeer has been initialized
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetPeerConfiguration.kDefaultMTU">
            <summary>
            Default MTU value in bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerConfiguration.#ctor(System.String)">
            <summary>
            NetPeerConfiguration constructor
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.AppIdentifier">
            <summary>
            Gets the identifier of this application; the library can only connect to matching app identifier peers
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerConfiguration.EnableMessageType(Lidgren.Network.NetIncomingMessageType)">
            <summary>
            Enables receiving of the specified type of message
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerConfiguration.DisableMessageType(Lidgren.Network.NetIncomingMessageType)">
            <summary>
            Disables receiving of the specified type of message
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerConfiguration.SetMessageTypeEnabled(Lidgren.Network.NetIncomingMessageType,System.Boolean)">
            <summary>
            Enables or disables receiving of the specified type of message
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerConfiguration.IsMessageTypeEnabled(Lidgren.Network.NetIncomingMessageType)">
            <summary>
            Gets if receiving of the specified type of message is enabled
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.UnreliableSizeBehaviour">
            <summary>
            Gets or sets the behaviour of unreliable sends above MTU
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.NetworkThreadName">
            <summary>
            Gets or sets the name of the library network thread. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.MaximumConnections">
            <summary>
            Gets or sets the maximum amount of connections this peer can hold. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.MaximumTransmissionUnit">
            <summary>
            Gets or sets the maximum amount of bytes to send in a single packet, excluding ip, udp and lidgren headers. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.DefaultOutgoingMessageCapacity">
            <summary>
            Gets or sets the default capacity in bytes when NetPeer.CreateMessage() is called without argument
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.PingInterval">
            <summary>
            Gets or sets the time between latency calculating pings
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.UseMessageRecycling">
            <summary>
            Gets or sets if the library should recycling messages to avoid excessive garbage collection. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.RecycledCacheMaxCount">
            <summary>
            Gets or sets the maximum number of incoming/outgoing messages to keep in the recycle cache.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.ConnectionTimeout">
            <summary>
            Gets or sets the number of seconds timeout will be postponed on a successful ping/pong
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.EnableUPnP">
            <summary>
            Enables UPnP support; enabling port forwarding and getting external ip
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.AutoFlushSendQueue">
            <summary>
            Enables or disables automatic flushing of the send queue. If disabled, you must manully call NetPeer.FlushSendQueue() to flush sent messages to network.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SuppressUnreliableUnorderedAcks">
            <summary>
            If true, will not send acks for unreliable unordered messages. This will save bandwidth, but disable flow control and duplicate detection for this type of messages.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.LocalAddress">
            <summary>
            Gets or sets the local ip address to bind to. Defaults to IPAddress.Any. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.BroadcastAddress">
            <summary>
            Gets or sets the local broadcast address to use when broadcasting
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.Port">
            <summary>
            Gets or sets the local port to bind to. Defaults to 0. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.ReceiveBufferSize">
            <summary>
            Gets or sets the size in bytes of the receiving buffer. Defaults to 131071 bytes. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SendBufferSize">
            <summary>
            Gets or sets the size in bytes of the sending buffer. Defaults to 131071 bytes. Cannot be changed once NetPeer is initialized.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.AcceptIncomingConnections">
            <summary>
            Gets or sets if the NetPeer should accept incoming connections. This is automatically set to true in NetServer and false in NetClient.
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.ResendHandshakeInterval">
            <summary>
            Gets or sets the number of seconds between handshake attempts
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.MaximumHandshakeAttempts">
            <summary>
            Gets or sets the maximum number of handshake attempts before failing to connect
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.AutoExpandMTU">
            <summary>
            Gets or sets if the NetPeer should send large messages to try to expand the maximum transmission unit size
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.ExpandMTUFrequency">
            <summary>
            Gets or sets how often to send large messages to expand MTU if AutoExpandMTU is enabled
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.ExpandMTUFailAttempts">
            <summary>
            Gets or sets the number of failed expand mtu attempts to perform before setting final MTU
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SimulatedLoss">
            <summary>
            Gets or sets the simulated amount of sent packets lost from 0.0f to 1.0f
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SimulatedMinimumLatency">
            <summary>
            Gets or sets the minimum simulated amount of one way latency for sent packets in seconds
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SimulatedRandomLatency">
            <summary>
            Gets or sets the simulated added random amount of one way latency for sent packets in seconds
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SimulatedAverageLatency">
            <summary>
            Gets the average simulated one way latency in seconds
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerConfiguration.SimulatedDuplicatesChance">
            <summary>
            Gets or sets the simulated amount of duplicated packets from 0.0f to 1.0f
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerConfiguration.Clone">
            <summary>
            Creates a memberwise shallow clone of this configuration
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetUnreliableSizeBehaviour">
            <summary>
            Behaviour of unreliable sends above MTU
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetUnreliableSizeBehaviour.IgnoreMTU">
            <summary>
            Sending an unreliable message will ignore MTU and send everything in a single packet; this is the new default
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetUnreliableSizeBehaviour.NormalFragmentation">
            <summary>
            Old behaviour; use normal fragmentation for unreliable messages - if a fragment is dropped, memory for received fragments are never reclaimed!
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetUnreliableSizeBehaviour.DropAboveMTU">
            <summary>
            Alternate behaviour; just drops unreliable messages above MTU
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetPeerStatistics">
            <summary>
            Statistics for a NetPeer instance
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.SentPackets">
            <summary>
            Gets the number of sent packets since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.ReceivedPackets">
            <summary>
            Gets the number of received packets since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.SentMessages">
            <summary>
            Gets the number of sent messages since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.ReceivedMessages">
            <summary>
            Gets the number of received messages since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.SentBytes">
            <summary>
            Gets the number of sent bytes since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.ReceivedBytes">
            <summary>
            Gets the number of received bytes since the NetPeer was initialized
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.StorageBytesAllocated">
            <summary>
            Gets the number of bytes allocated (and possibly garbage collected) for message storage
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetPeerStatistics.BytesInRecyclePool">
            <summary>
            Gets the number of bytes in the recycled pool
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetPeerStatistics.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetPeerStatus">
            <summary>
            Status for a NetPeer instance
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetPeerStatus.NotRunning">
            <summary>
            NetPeer is not running; socket is not bound
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetPeerStatus.Starting">
            <summary>
            NetPeer is in the process of starting up
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetPeerStatus.Running">
            <summary>
            NetPeer is bound to socket and listening for packets
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetPeerStatus.ShutdownRequested">
            <summary>
            Shutdown has been requested and will be executed shortly
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetQueue`1">
            <summary>
            Thread safe (blocking) expanding queue with TryDequeue() and EnqueueFirst()
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetQueue`1.Count">
            <summary>
            Gets the number of items in the queue
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetQueue`1.Capacity">
            <summary>
            Gets the current capacity for the queue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.#ctor(System.Int32)">
            <summary>
            NetQueue constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.Enqueue(`0)">
            <summary>
            Adds an item last/tail of the queue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.Enqueue(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds an item last/tail of the queue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.EnqueueFirst(`0)">
            <summary>
            Places an item first, at the head of the queue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.TryDequeue(`0@)">
            <summary>
            Gets an item from the head of the queue, or returns default(T) if empty
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.TryDrain(System.Collections.Generic.IList{`0})">
            <summary>
            Gets all items from the head of the queue, or returns number of items popped
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.TryPeek(System.Int32)">
            <summary>
            Returns default(T) if queue is empty
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.Contains(`0)">
            <summary>
            Determines whether an item is in the queue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.ToArray">
            <summary>
            Copies the queue items to a new array
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetQueue`1.Clear">
            <summary>
            Removes all objects from the queue
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetRandom">
            <summary>
            NetRandom base class
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetRandom.Instance">
            <summary>
            Get global instance of NetRandom (uses MWCRandom)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.#ctor">
            <summary>
            Constructor with randomized seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.#ctor(System.Int32)">
            <summary>
            Constructor with provided 32 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.Initialize(System.UInt32)">
            <summary>
            (Re)initialize this instance with provided 32 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextUInt32">
            <summary>
            Generates a random value from UInt32.MinValue to UInt32.MaxValue, inclusively
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.Next">
            <summary>
            Generates a random value that is greater or equal than 0 and less than Int32.MaxValue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextInt32">
            <summary>
            Generates a random value greater or equal than 0 and less or equal than Int32.MaxValue (inclusively)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextDouble">
            <summary>
            Returns random value larger or equal to 0.0 and less than 1.0
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.Sample">
            <summary>
            Returns random value is greater or equal than 0.0 and less than 1.0
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextSingle">
            <summary>
            Returns random value is greater or equal than 0.0f and less than 1.0f
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.Next(System.Int32)">
            <summary>
            Returns a random value is greater or equal than 0 and less than maxValue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random value is greater or equal than minValue and less than maxValue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextUInt64">
            <summary>
            Generates a random value between UInt64.MinValue to UInt64.MaxValue
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextBool">
            <summary>
            Returns true or false, randomly
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Fills all bytes from offset to offset + length in buffer with random values
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandom.NextBytes(System.Byte[])">
            <summary>
            Fill the specified buffer with random values
            </summary>
        </member>
        <member name="T:Lidgren.Network.MWCRandom">
            <summary>
            Multiply With Carry random
            </summary>
        </member>
        <member name="F:Lidgren.Network.MWCRandom.Instance">
            <summary>
            Get global instance of MWCRandom
            </summary>
        </member>
        <member name="M:Lidgren.Network.MWCRandom.#ctor">
            <summary>
            Constructor with randomized seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.MWCRandom.Initialize(System.UInt32)">
            <summary>
            (Re)initialize this instance with provided 32 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.MWCRandom.Initialize(System.UInt64)">
            <summary>
            (Re)initialize this instance with provided 64 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.MWCRandom.NextUInt32">
            <summary>
            Generates a random value from UInt32.MinValue to UInt32.MaxValue, inclusively
            </summary>
        </member>
        <member name="T:Lidgren.Network.XorShiftRandom">
            <summary>
            Xor Shift based random
            </summary>
        </member>
        <member name="F:Lidgren.Network.XorShiftRandom.Instance">
            <summary>
            Get global instance of XorShiftRandom
            </summary>
        </member>
        <member name="M:Lidgren.Network.XorShiftRandom.#ctor">
            <summary>
            Constructor with randomized seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.XorShiftRandom.#ctor(System.UInt64)">
            <summary>
            Constructor with provided 64 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.XorShiftRandom.Initialize(System.UInt32)">
            <summary>
            (Re)initialize this instance with provided 32 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.XorShiftRandom.Initialize(System.UInt64)">
            <summary>
            (Re)initialize this instance with provided 64 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.XorShiftRandom.NextUInt32">
            <summary>
            Generates a random value from UInt32.MinValue to UInt32.MaxValue, inclusively
            </summary>
        </member>
        <member name="T:Lidgren.Network.MersenneTwisterRandom">
            <summary>
            Mersenne Twister based random
            </summary>
        </member>
        <member name="F:Lidgren.Network.MersenneTwisterRandom.Instance">
            <summary>
            Get global instance of MersenneTwisterRandom
            </summary>
        </member>
        <member name="M:Lidgren.Network.MersenneTwisterRandom.#ctor">
            <summary>
            Constructor with randomized seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.MersenneTwisterRandom.#ctor(System.UInt32)">
            <summary>
            Constructor with provided 32 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.MersenneTwisterRandom.Initialize(System.UInt32)">
            <summary>
            (Re)initialize this instance with provided 32 bit seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.MersenneTwisterRandom.NextUInt32">
            <summary>
            Generates a random value from UInt32.MinValue to UInt32.MaxValue, inclusively
            </summary>
        </member>
        <member name="T:Lidgren.Network.CryptoRandom">
            <summary>
            RNGCryptoServiceProvider based random; very slow but cryptographically safe
            </summary>
        </member>
        <member name="F:Lidgren.Network.CryptoRandom.Instance">
            <summary>
            Global instance of CryptoRandom
            </summary>
        </member>
        <member name="M:Lidgren.Network.CryptoRandom.Initialize(System.UInt32)">
            <summary>
            Seed in CryptoRandom does not create deterministic sequences
            </summary>
        </member>
        <member name="M:Lidgren.Network.CryptoRandom.NextUInt32">
            <summary>
            Generates a random value from UInt32.MinValue to UInt32.MaxValue, inclusively
            </summary>
        </member>
        <member name="M:Lidgren.Network.CryptoRandom.NextBytes(System.Byte[])">
            <summary>
            Fill the specified buffer with random values
            </summary>
        </member>
        <member name="M:Lidgren.Network.CryptoRandom.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Fills all bytes from offset to offset + length in buffer with random values
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetRandomSeed">
            <summary>
            Class for generating random seeds
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandomSeed.GetUInt32">
            <summary>
            Generates a 32 bit random seed
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetRandomSeed.GetUInt64">
            <summary>
            Generates a 64 bit random seed
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetReliableSenderChannel">
            <summary>
            Sender part of Selective repeat ARQ for a particular NetChannel
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetSendResult">
            <summary>
            Result of a SendMessage call
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetSendResult.FailedNotConnected">
            <summary>
            Message failed to enqueue because there is no connection
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetSendResult.Sent">
            <summary>
            Message was immediately sent
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetSendResult.Queued">
            <summary>
            Message was queued for delivery
            </summary>
        </member>
        <member name="F:Lidgren.Network.NetSendResult.Dropped">
            <summary>
            Message was dropped immediately since too many message were queued
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetServer">
            <summary>
            Specialized version of NetPeer used for "server" peers
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetServer.#ctor(Lidgren.Network.NetPeerConfiguration)">
            <summary>
            NetServer constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetServer.SendToAll(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetDeliveryMethod)">
            <summary>
            Send a message to all connections
            </summary>
            <param name="msg">The message to send</param>
            <param name="method">How to deliver the message</param>
        </member>
        <member name="M:Lidgren.Network.NetServer.SendToAll(Lidgren.Network.NetOutgoingMessage,Lidgren.Network.NetConnection,Lidgren.Network.NetDeliveryMethod,System.Int32)">
            <summary>
            Send a message to all connections except one
            </summary>
            <param name="msg">The message to send</param>
            <param name="method">How to deliver the message</param>
            <param name="except">Don't send to this particular connection</param>
            <param name="sequenceChannel">Which sequence channel to use for the message</param>
        </member>
        <member name="M:Lidgren.Network.NetServer.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetServer.Recycle(Lidgren.Network.NetOutgoingMessage)">
            <summary>
            Упокоить сообщение
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:Lidgren.Network.NetSRP">
            <summary>
            Helper methods for implementing SRP authentication
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeMultiplier">
            <summary>
            Compute multiplier (k)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.CreateRandomSalt">
            <summary>
            Create 16 bytes of random salt
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.CreateRandomEphemeral">
            <summary>
            Create 32 bytes of random ephemeral value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputePrivateKey(System.String,System.String,System.Byte[])">
            <summary>
            Computer private key (x)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeServerVerifier(System.Byte[])">
            <summary>
            Creates a verifier that the server can later use to authenticate users later on (v)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeClientEphemeral(System.Byte[])">
            <summary>
            Compute client public ephemeral value (A)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeServerEphemeral(System.Byte[],System.Byte[])">
            <summary>
            Compute server ephemeral value (B)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeU(System.Byte[],System.Byte[])">
            <summary>
            Compute intermediate value (u)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeServerSessionValue(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Computes the server session value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.ComputeClientSessionValue(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Computes the client session value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetSRP.CreateEncryption(Lidgren.Network.NetPeer,System.Byte[])">
            <summary>
            Create XTEA symmetrical encryption object from sessionValue
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetTime">
            <summary>
            Time service
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetTime.ToReadable(System.Double)">
            <summary>
            Given seconds it will output a human friendly readable string (milliseconds if less than 60 seconds)
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetTime.Now">
            <summary>
            Get number of seconds since the application started
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetUnreliableSenderChannel">
            <summary>
            Sender part of Selective repeat ARQ for a particular NetChannel
            </summary>
        </member>
        <member name="T:Lidgren.Network.UPnPStatus">
            <summary>
            Status of the UPnP capabilities
            </summary>
        </member>
        <member name="F:Lidgren.Network.UPnPStatus.Discovering">
            <summary>
            Still discovering UPnP capabilities
            </summary>
        </member>
        <member name="F:Lidgren.Network.UPnPStatus.NotAvailable">
            <summary>
            UPnP is not available
            </summary>
        </member>
        <member name="F:Lidgren.Network.UPnPStatus.Available">
            <summary>
            UPnP is available and ready to use
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetUPnP">
            <summary>
            UPnP support class
            </summary>
        </member>
        <member name="P:Lidgren.Network.NetUPnP.Status">
            <summary>
            Status of the UPnP capabilities of this NetPeer
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUPnP.#ctor(Lidgren.Network.NetPeer)">
            <summary>
            NetUPnP constructor
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUPnP.ForwardPort(System.Int32,System.String)">
            <summary>
            Add a forwarding rule to the router using UPnP
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUPnP.DeleteForwardingRule(System.Int32)">
            <summary>
            Delete a forwarding rule from the router using UPnP
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUPnP.GetExternalIP">
            <summary>
            Retrieve the extern ip using UPnP
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetUtility">
            <summary>
            Utility methods
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetUtility.ResolveEndPointCallback">
            <summary>
            Resolve endpoint callback
            </summary>
        </member>
        <member name="T:Lidgren.Network.NetUtility.ResolveAddressCallback">
            <summary>
            Resolve address callback
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ResolveAsync(System.String,System.Int32,Lidgren.Network.NetUtility.ResolveEndPointCallback)">
            <summary>
            Get IPv4 endpoint from notation (xxx.xxx.xxx.xxx) or hostname and port number (asynchronous version)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.Resolve(System.String,System.Int32)">
            <summary>
            Get IPv4 endpoint from notation (xxx.xxx.xxx.xxx) or hostname and port number
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ResolveAsync(System.String,Lidgren.Network.NetUtility.ResolveAddressCallback)">
            <summary>
            Get IPv4 address from notation (xxx.xxx.xxx.xxx) or hostname (asynchronous version)
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.Resolve(System.String)">
            <summary>
            Get IPv4 address from notation (xxx.xxx.xxx.xxx) or hostname
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ToHexString(System.Int64)">
            <summary>
            Create a hex string from an Int64 value
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ToHexString(System.Byte[])">
            <summary>
            Create a hex string from an array of bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ToHexString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a hex string from an array of bytes
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.IsLocal(System.Net.IPEndPoint)">
            <summary>
            Returns true if the endpoint supplied is on the same subnet as this host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.IsLocal(System.Net.IPAddress)">
            <summary>
            Returns true if the IPAddress supplied is on the same subnet as this host
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.BitsToHoldUInt(System.UInt32)">
            <summary>
            Returns how many bits are necessary to hold a certain number
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.BitsToHoldUInt64(System.UInt64)">
            <summary>
            Returns how many bits are necessary to hold a certain number
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.BytesToHoldBits(System.Int32)">
            <summary>
            Returns how many bytes are required to hold a certain number of bits
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ToByteArray(System.String)">
            <summary>
            Convert a hexadecimal string to a byte array
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.ToHumanReadable(System.Int64)">
            <summary>
            Converts a number of bytes to a shorter, more readable string representation
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.GetWindowSize(Lidgren.Network.NetDeliveryMethod)">
            <summary>
            Gets the window size used internally in the library for a certain delivery method
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.MakeCommaDelimitedList``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates a comma delimited string from a lite of items
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.GetMacAddressBytes">
            <summary>
            If available, returns the bytes of the physical (MAC) address for the first usable network interface
            </summary>
        </member>
        <member name="M:Lidgren.Network.NetUtility.GetMyAddress(System.Net.IPAddress@)">
            <summary>
            Gets my local IPv4 address (not necessarily external) and subnet mask
            </summary>
        </member>
        <member name="T:Octree.BoundingBox">
            <summary>
            Represents an axis aligned bounding box (AABB).
            </summary>
            <remarks>
            This class was inspired by the Bounds type of the Unity Engine and 
            designed with the exact same interface to provide maximum compatibility.
            </remarks>
        </member>
        <member name="P:Octree.BoundingBox.Center">
            <summary>
            Gets or sets the center of the bounding box.
            </summary>
        </member>
        <member name="P:Octree.BoundingBox.Extents">
            <summary>
            Gets or sets the extents of the bounding box. This is always half of the <see cref="P:Octree.BoundingBox.Size"/>.
            </summary>
        </member>
        <member name="P:Octree.BoundingBox.Size">
            <summary>
            Gets or sets the size of the bounding box. This is always twice as large as the <see cref="P:Octree.BoundingBox.Extents"/>.
            </summary>
        </member>
        <member name="P:Octree.BoundingBox.Min">
            <summary>
            Gets or sets the minimal point of the box.
            </summary>
            <remarks>
            This is always equal to <c>center-extents</c>.
            </remarks>
        </member>
        <member name="P:Octree.BoundingBox.Max">
            <summary>
            Gets or sets the maximal point of the box.
            </summary>
            <remarks>
            This is always equal to <c>center+extents</c>.
            </remarks>
        </member>
        <member name="M:Octree.BoundingBox.#ctor(GalaxyCoreCommon.GalaxyVector3,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Creates a new bounding box.
            </summary>
            <param name="center">The center of the box.</param>
            <param name="size">The size of the box.</param>
        </member>
        <member name="M:Octree.BoundingBox.SetMinMax(GalaxyCoreCommon.GalaxyVector3,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Sets the bounds to the min and max value of the box.
            </summary>
            <param name="min">The minimal point.</param>
            <param name="max">The maximal point.</param>
        </member>
        <member name="M:Octree.BoundingBox.Encapsulate(GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Grows the bounding box include the point.
            </summary>
            <param name="point">The specified point to include.</param>
        </member>
        <member name="M:Octree.BoundingBox.Encapsulate(Octree.BoundingBox)">
            <summary>
            Grows the bounding box include the other box.
            </summary>
            <param name="box">The specified box to include.</param>
        </member>
        <member name="M:Octree.BoundingBox.Expand(System.Single)">
            <summary>
            Expands the bounds by increasing its <see cref="P:Octree.BoundingBox.Size"/> by <paramref name="amount"/> along each side.
            </summary>
            <param name="amount">The expansions for each dimension.</param>
        </member>
        <member name="M:Octree.BoundingBox.Expand(GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Expands the bounds by increasing its <see cref="P:Octree.BoundingBox.Size"/> by <paramref name="amount"/> along each side.
            </summary>
            <param name="amount">The expansions for each dimension in order.</param>
        </member>
        <member name="M:Octree.BoundingBox.Contains(GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Determines whether the box contains the point.
            </summary>
            <param name="point">The point to test.</param>
            <returns><c>true</c> if the box contains the point; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Octree.BoundingBox.Intersects(Octree.BoundingBox)">
            <summary>
            Determines whether the bounding box intersects with another box.
            </summary>
            <param name="box">The box to test.</param>
            <returns><c>true</c> if the bounding box intersects with another box, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Octree.BoundingBox.IntersectRay(Octree.Ray)">
            <summary>
            Determines whether the bounding box intersects with a ray.
            </summary>
            <param name="ray">The ray to test.</param>
            <returns><c>true</c> if the box intersects with the ray, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Octree.BoundingBox.IntersectRay(Octree.Ray,System.Single@)">
            <summary>
            Determines whether the bounding box intersects with a ray.
            </summary>
            <param name="ray">The ray to test.</param>
            <param name="distance">The calculated distance from the origin of the ray to the box along the ray.</param>
            <returns><c>true</c> if the box intersects with the ray, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Octree.BoundingBox.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="M:Octree.BoundingBox.Equals(System.Object)">
            <summary>
            Determines whether the specified object as a <see cref="T:Octree.BoundingBox" /> is equal to this instance.
            </summary>
            <param name="other">The <see cref="T:Octree.BoundingBox" /> object to compare with this instance.</param>
            <returns><c>true</c> if the specified box is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Octree.BoundingBox.ToString">
            <summary>
            Returns a nicely formatted string for this bounding box.
            </summary>
        </member>
        <member name="M:Octree.BoundingBox.ToString(System.String)">
            <summary>
            Returns a nicely formatted string for this bounding box.
            </summary>
            <param name="format">The format for the center and the extent.</param>
        </member>
        <member name="M:Octree.BoundingBox.op_Equality(Octree.BoundingBox,Octree.BoundingBox)">
            <summary>
            Determines whether two bounding boxes are equal.
            </summary>
            <param name="lhs">The first box.</param>
            <param name="rhs">The second box.</param>
        </member>
        <member name="M:Octree.BoundingBox.op_Inequality(Octree.BoundingBox,Octree.BoundingBox)">
            <summary>
            Determines whether two bounding boxes are different.
            </summary>
            <param name="lhs">The first box.</param>
            <param name="rhs">The second box.</param>
        </member>
        <member name="T:Octree.MathExtensions">
            <summary>
            Auxiliary mathematical functions.
            </summary>
        </member>
        <member name="M:Octree.MathExtensions.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Clamps a value between a minimum and maximum value.
            </summary>
            <param name="value">The value.</param>
            <param name="min">The minimum.</param>
            <param name="max">The maximum.</param>
            <returns>The clamped value.</returns>
        </member>
        <member name="T:Octree.Point">
            <summary>
            Representation of 3D points and vectors.
            </summary>
            <remarks>
            This class was inspired by the Vector3 type of the Unity Engine and 
            designed with the exact same interface to provide maximum compatibility.
            </remarks>
        </member>
        <member name="P:Octree.Point.X">
            <summary>
            Gets or sets the X coordinate.
            </summary>
        </member>
        <member name="P:Octree.Point.Y">
            <summary>
            Gets or sets the Y coordinate.
            </summary>
        </member>
        <member name="P:Octree.Point.Z">
            <summary>
            Gets or sets the Z coordinate.
            </summary>
        </member>
        <member name="P:Octree.Point.Magnitude">
            <summary>
            Gets the length of the vector.
            </summary>
        </member>
        <member name="P:Octree.Point.SqrMagnitude">
            <summary>
            Gets the squared length of the vector.
            </summary>
        </member>
        <member name="P:Octree.Point.Normalized">
            <summary>
            Gets the vector with a magnitude of 1.
            </summary>
        </member>
        <member name="M:Octree.Point.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates a new vector with given coordinates.
            </summary>
            <param name="x">The X coordinate.</param>
            <param name="y">The Y coordinate.</param>
            <param name="z">The Z coordinate.</param>
        </member>
        <member name="M:Octree.Point.Normalize">
            <summary>
            Normalizes the vector with a magnitude of 1.
            </summary>
        </member>
        <member name="M:Octree.Point.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="M:Octree.Point.Equals(System.Object)">
            <summary>
            Determines whether the specified object as a <see cref="T:Octree.Point" /> is exactly equal to this instance.
            </summary>
            <remarks>
            Due to floating point inaccuracies, this might return false for vectors which are essentially (but not exactly) equal. Use the <see cref="M:Octree.Point.op_Equality(Octree.Point,Octree.Point)"/> to test two points for approximate equality.
            </remarks>
            <param name="other">The <see cref="T:Octree.Point" /> object to compare with this instance.</param>
            <returns><c>true</c> if the specified point is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Octree.Point.ToString">
            <summary>
            Returns a nicely formatted string for this vector.
            </summary>
        </member>
        <member name="M:Octree.Point.ToString(System.String)">
            <summary>
            Returns a nicely formatted string for this vector.
            </summary>
            <param name="format">The format for each coordinate.</param>
        </member>
        <member name="F:Octree.Point.Zero">
            <summary>
            Shorthand for writing Point(0, 0, 0).
            </summary>
        </member>
        <member name="F:Octree.Point.One">
            <summary>
            Shorthand for writing Point(1, 1, 1).
            </summary>
        </member>
        <member name="F:Octree.Point.Forward">
            <summary>
            Shorthand for writing Point(0, 0, 1).
            </summary>
        </member>
        <member name="F:Octree.Point.Back">
            <summary>
            Shorthand for writing Point(0, 0, -1).
            </summary>
        </member>
        <member name="F:Octree.Point.Up">
            <summary>
            Shorthand for writing Point(0, 1, 0).
            </summary>
        </member>
        <member name="F:Octree.Point.Down">
            <summary>
            Shorthand for writing Point(0, -1, 0).
            </summary>
        </member>
        <member name="F:Octree.Point.Left">
            <summary>
            Shorthand for writing Point(-1, 0, 0).
            </summary>
        </member>
        <member name="F:Octree.Point.Right">
            <summary>
            Shorthand for writing Point(1, 0, 0).
            </summary>
        </member>
        <member name="M:Octree.Point.Distance(Octree.Point,Octree.Point)">
            <summary>
            Returns the distance between two points.
            </summary>
            <param name="a">The first point.</param>
            <param name="b">The second point.</param>
            <returns>The distance.</returns>
        </member>
        <member name="M:Octree.Point.Scale(Octree.Point,Octree.Point)">
            <summary>
            Multiplies two vectors component-wise.
            </summary>
            <param name="a">The first vector.</param>
            <param name="b">The second vector.</param>
            <returns>The scaled up vector.</returns>
        </member>
        <member name="M:Octree.Point.Cross(Octree.Point,Octree.Point)">
            <summary>
            Cross-product of two vectors.
            </summary>
            <param name="a">The first vector.</param>
            <param name="b">The second vector.</param>
            <returns>The cross product vector.</returns>
        </member>
        <member name="M:Octree.Point.Dot(Octree.Point,Octree.Point)">
            <summary>
            Dot-product of two vectors.
            </summary>
            <param name="a">The first vector.</param>
            <param name="b">The second vector.</param>
            <returns>The dot product vector.</returns>
        </member>
        <member name="M:Octree.Point.Min(Octree.Point,Octree.Point)">
            <summary>
            Returns a point that is made from the smallest components of two points.
            </summary>
            <param name="a">The first point.</param>
            <param name="b">The second point.</param>
            <returns>The minimal coordinates.</returns>
        </member>
        <member name="M:Octree.Point.Max(Octree.Point,Octree.Point)">
            <summary>
            Returns a point that is made from the largest components of two points.
            </summary>
            <param name="a">The first point.</param>
            <param name="b">The second point.</param>
            <returns>The maximal coordinates.</returns>
        </member>
        <member name="M:Octree.Point.op_Addition(Octree.Point,Octree.Point)">
            <summary>
            Adds two vectors.
            </summary>
            <param name="a">The first vector.</param>
            <param name="b">The second vector.</param>
        </member>
        <member name="M:Octree.Point.op_Subtraction(Octree.Point,Octree.Point)">
            <summary>
            Subtracts one vector from another.
            </summary>
            <param name="a">The first vector.</param>
            <param name="b">The second vector.</param>
        </member>
        <member name="M:Octree.Point.op_UnaryNegation(Octree.Point)">
            <summary>
            Negates a vector.
            </summary>
            <param name="a">The vector.</param>
        </member>
        <member name="M:Octree.Point.op_Multiply(Octree.Point,System.Single)">
            <summary>
            Multiplies a vector by a number.
            </summary>
            <param name="a">The vector.</param>
            <param name="d">The number.</param>
        </member>
        <member name="M:Octree.Point.op_Multiply(System.Single,Octree.Point)">
            <summary>
            Multiplies a vector by a number.
            </summary>
            <param name="d">The number.</param>
            <param name="a">The vector.</param>
        </member>
        <member name="M:Octree.Point.op_Division(Octree.Point,System.Single)">
            <summary>
            Divides a vector by a number.
            </summary>
            <param name="a">The vector.</param>
            <param name="d">The number.</param>
        </member>
        <member name="M:Octree.Point.op_Equality(Octree.Point,Octree.Point)">
            <summary>
            Determines whether two points are approximately equal.
            </summary>
            <remarks>
            To allow for floating point inaccuracies, the two vectors are considered equal if the magnitude of their difference is less than 1e-5..
            </remarks>
            <param name="a">The first point.</param>
            <param name="b">The second point.</param>
        </member>
        <member name="M:Octree.Point.op_Inequality(Octree.Point,Octree.Point)">
            <summary>
            Determines whether two points are different.
            </summary>
            <remarks>
            To allow for floating point inaccuracies, the two vectors are considered equal if the magnitude of their difference is less than 1e-5.
            </remarks>
            <param name="a">The first point.</param>
            <param name="b">The second point.</param>
        </member>
        <member name="T:Octree.Ray">
            <summary>
            Representation of rays.
            </summary>
            <remarks>
            A ray is an infinite line starting at <see cref="P:Octree.Ray.Origin"/> and going in some <see cref="P:Octree.Ray.Direction"/>.
            
            This class was inspired by the Ray type of the Unity Engine and 
            designed with the exact same interface to provide maximum compatibility.
            </remarks>
        </member>
        <member name="P:Octree.Ray.Origin">
            <summary>
            Gets or sets the origin of the ray.
            </summary>
        </member>
        <member name="F:Octree.Ray._direction">
            <summary>
            The direction of the ray.
            </summary>
        </member>
        <member name="P:Octree.Ray.Direction">
            <summary>
            Gets or sets the direction of the ray.
            </summary>
        </member>
        <member name="M:Octree.Ray.#ctor(GalaxyCoreCommon.GalaxyVector3,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Creates a ray starting at origin along direction.
            </summary>
            <param name="origin">The origin of the ray.</param>
            <param name="direction">The direction of the ray.</param>
        </member>
        <member name="M:Octree.Ray.GetPoint(System.Single)">
            <summary>
            Returns a point at the given distance along the ray.
            </summary>
            <param name="distance">The distance.</param>
            <returns>The point on the ray.</returns>
        </member>
        <member name="M:Octree.Ray.ToString">
            <summary>
            Returns a nicely formatted string for this ray.
            </summary>
        </member>
        <member name="M:Octree.Ray.ToString(System.String)">
            <summary>
            Returns a nicely formatted string for this ray.
            </summary>
            <param name="format">The format for the origin and direction.</param>
        </member>
        <member name="T:Octree.PointOctree`1">
            <summary>
            A Dynamic Octree for storing any objects that can be described as a single point
            </summary>
            <seealso cref="!:BoundsOctree&lt;T&gt;"/>
            <remarks>
            Octree:	An octree is a tree data structure which divides 3D space into smaller partitions (nodes) 
            and places objects into the appropriate nodes. This allows fast access to objects
            in an area of interest without having to check every object.
            
            Dynamic: The octree grows or shrinks as required when objects as added or removed.
            It also splits and merges nodes as appropriate. There is no maximum depth.
            Nodes have a constant - <see cref="F:Octree.PointOctree`1.Node.NumObjectsAllowed"/> - which sets the amount of items allowed in a node before it splits.
            
            See also BoundsOctree, where objects are described by AABB bounds.
            </remarks>
            <typeparam name="T">The content of the octree can be anything, since the bounds data is supplied separately.</typeparam>
        </member>
        <member name="F:Octree.PointOctree`1._rootNode">
            <summary>
            Root node of the octree
            </summary>
        </member>
        <member name="F:Octree.PointOctree`1._initialSize">
            <summary>
            Size that the octree was on creation
            </summary>
        </member>
        <member name="F:Octree.PointOctree`1._minSize">
            <summary>
            Minimum side length that a node can be - essentially an alternative to having a max depth
            </summary>
        </member>
        <member name="P:Octree.PointOctree`1.Count">
            <summary>
            The total amount of objects currently in the tree
            </summary>
        </member>
        <member name="P:Octree.PointOctree`1.MaxBounds">
            <summary>
            Gets the bounding box that represents the whole octree
            </summary>
            <value>The bounding box of the root node.</value>
        </member>
        <member name="M:Octree.PointOctree`1.#ctor(System.Single,GalaxyCoreCommon.GalaxyVector3,System.Single)">
            <summary>
            Constructor for the point octree.
            </summary>
            <param name="initialWorldSize">Size of the sides of the initial node. The octree will never shrink smaller than this.</param>
            <param name="initialWorldPos">Position of the centre of the initial node.</param>
            <param name="minNodeSize">Nodes will stop splitting if the new nodes would be smaller than this.</param>
        </member>
        <member name="M:Octree.PointOctree`1.Add(`0,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Add an object.
            </summary>
            <param name="obj">Object to add.</param>
            <param name="objPos">Position of the object.</param>
        </member>
        <member name="M:Octree.PointOctree`1.Remove(`0)">
            <summary>
            Remove an object. Makes the assumption that the object only exists once in the tree.
            </summary>
            <param name="obj">Object to remove.</param>
            <returns>True if the object was removed successfully.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Remove(`0,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Removes the specified object at the given position. Makes the assumption that the object only exists once in the tree.
            </summary>
            <param name="obj">Object to remove.</param>
            <param name="objPos">Position of the object.</param>
            <returns>True if the object was removed successfully.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.GetNearby(Octree.Ray,System.Single)">
            <summary>
            Returns objects that are within <paramref name="maxDistance"/> of the specified ray.
            If none, returns an empty array (not null).
            </summary>
            <param name="ray">The ray. Passing as ref to improve performance since it won't have to be copied.</param>
            <param name="maxDistance">Maximum distance from the ray to consider.</param>
            <returns>Objects within range.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.GetNearby(GalaxyCoreCommon.GalaxyVector3,System.Single)">
            <summary>
            Returns objects that are within <paramref name="maxDistance"/> of the specified position.
            If none, returns an empty array (not null).
            </summary>
            <param name="position">The position. Passing as ref to improve performance since it won't have to be copied.</param>
            <param name="maxDistance">Maximum distance from the position to consider.</param>
            <returns>Objects within range.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.GetAll">
            <summary>
            Returns all objects in the tree.
            If none, returns an empty array (not null).
            </summary>
            <returns>All objects.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Grow(GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Grow the octree to fit in all objects.
            </summary>
            <param name="direction">Direction to grow.</param>
        </member>
        <member name="M:Octree.PointOctree`1.Shrink">
            <summary>
            Shrink the octree if possible, else leave it the same.
            </summary>
        </member>
        <member name="T:Octree.PointOctree`1.Node">
            <summary>
            A node in a PointOctree
            </summary>
        </member>
        <member name="P:Octree.PointOctree`1.Node.Center">
            <summary>
            Center of this node
            </summary>
        </member>
        <member name="P:Octree.PointOctree`1.Node.SideLength">
            <summary>
            Length of the sides of this node
            </summary>
        </member>
        <member name="F:Octree.PointOctree`1.Node._minSize">
            <summary>
            Minimum size for a node in this octree
            </summary>
        </member>
        <member name="F:Octree.PointOctree`1.Node._bounds">
            <summary>
            Bounding box that represents this node
            </summary>
        </member>
        <member name="F:Octree.PointOctree`1.Node._objects">
            <summary>
            Objects in this node
            </summary>
        </member>
        <member name="F:Octree.PointOctree`1.Node._children">
            <summary>
            Child nodes, if any
            </summary>
        </member>
        <member name="F:Octree.PointOctree`1.Node._childBounds">
            <summary>
            Bounds of potential children to this node. These are actual size (with looseness taken into account), not base size
            </summary>
        </member>
        <member name="F:Octree.PointOctree`1.Node.NumObjectsAllowed">
            <summary>
            If there are already NumObjectsAllowed in a node, we split it into children
            </summary>
            <remarks>
            A generally good number seems to be something around 8-15
            </remarks>
        </member>
        <member name="F:Octree.PointOctree`1.Node._actualBoundsSize">
            <summary>
            For reverting the bounds size after temporary changes
            </summary>
        </member>
        <member name="P:Octree.PointOctree`1.Node.HasChildren">
            <summary>
            Gets a value indicating whether this node has children
            </summary>
        </member>
        <member name="T:Octree.PointOctree`1.Node.OctreeObject">
            <summary>
            An object in the octree
            </summary>
        </member>
        <member name="F:Octree.PointOctree`1.Node.OctreeObject.Obj">
            <summary>
            Object content
            </summary>
        </member>
        <member name="F:Octree.PointOctree`1.Node.OctreeObject.Pos">
            <summary>
            Object position
            </summary>
        </member>
        <member name="M:Octree.PointOctree`1.Node.#ctor(System.Single,System.Single,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Constructor.
            </summary>
            <param name="baseLengthVal">Length of this node, not taking looseness into account.</param>
            <param name="minSizeVal">Minimum size of nodes in this octree.</param>
            <param name="centerVal">Center position of this node.</param>
        </member>
        <member name="M:Octree.PointOctree`1.Node.Add(`0,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Add an object.
            </summary>
            <param name="obj">Object to add.</param>
            <param name="objPos">Position of the object.</param>
            <returns></returns>
        </member>
        <member name="M:Octree.PointOctree`1.Node.Remove(`0)">
            <summary>
            Remove an object. Makes the assumption that the object only exists once in the tree.
            </summary>
            <param name="obj">Object to remove.</param>
            <returns>True if the object was removed successfully.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Node.Remove(`0,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Removes the specified object at the given position. Makes the assumption that the object only exists once in the tree.
            </summary>
            <param name="obj">Object to remove.</param>
            <param name="objPos">Position of the object.</param>
            <returns>True if the object was removed successfully.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Node.GetNearby(Octree.Ray@,System.Single,System.Collections.Generic.List{`0})">
            <summary>
            Return objects that are within <paramref name="maxDistance"/> of the specified ray.
            </summary>
            <param name="ray">The ray.</param>
            <param name="maxDistance">Maximum distance from the ray to consider.</param>
            <param name="result">List result.</param>
            <returns>Objects within range.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Node.GetNearby(GalaxyCoreCommon.GalaxyVector3@,System.Single,System.Collections.Generic.List{`0})">
            <summary>
            Return objects that are within <paramref name="maxDistance"/> of the specified position.
            </summary>
            <param name="position">The position.</param>
            <param name="maxDistance">Maximum distance from the position to consider.</param>
            <param name="result">List result.</param>
            <returns>Objects within range.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Node.GetAll(System.Collections.Generic.List{`0})">
            <summary>
            Return all objects in the tree.
            </summary>
            <returns>All objects.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Node.SetChildren(Octree.PointOctree{`0}.Node[])">
            <summary>
            Set the 8 children of this octree.
            </summary>
            <param name="childOctrees">The 8 new child nodes.</param>
        </member>
        <member name="M:Octree.PointOctree`1.Node.ShrinkIfPossible(System.Single)">
            <summary>
            We can shrink the octree if:
            - This node is >= double minLength in length
            - All objects in the root node are within one octant
            - This node doesn't have children, or does but 7/8 children are empty
            We can also shrink it if there are no objects left at all!
            </summary>
            <param name="minLength">Minimum dimensions of a node in this octree.</param>
            <returns>The new root, or the existing one if we didn't shrink.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Node.BestFitChild(GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Find which child node this object would be most likely to fit in.
            </summary>
            <param name="objPos">The object's position.</param>
            <returns>One of the eight child octants.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Node.HasAnyObjects">
            <summary>
            Checks if this node or anything below it has something in it.
            </summary>
            <returns>True if this node or any of its children, grandchildren etc have something in them</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Node.SqrDistanceToRay(Octree.Ray,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Returns the squared distance to the given ray from a point.
            </summary>
            <param name="ray">The ray.</param>
            <param name="point">The point to check distance from the ray.</param>
            <returns>Squared distance from the point to the closest point of the ray.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Node.SetValues(System.Single,System.Single,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Set values for this node. 
            </summary>
            <param name="baseLengthVal">Length of this node, not taking looseness into account.</param>
            <param name="minSizeVal">Minimum size of nodes in this octree.</param>
            <param name="centerVal">Centre position of this node.</param>
        </member>
        <member name="M:Octree.PointOctree`1.Node.SubAdd(`0,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Private counterpart to the public Add method.
            </summary>
            <param name="obj">Object to add.</param>
            <param name="objPos">Position of the object.</param>
        </member>
        <member name="M:Octree.PointOctree`1.Node.SubRemove(`0,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Private counterpart to the public <see cref="M:Octree.PointOctree`1.Node.Remove(`0,GalaxyCoreCommon.GalaxyVector3)"/> method.
            </summary>
            <param name="obj">Object to remove.</param>
            <param name="objPos">Position of the object.</param>
            <returns>True if the object was removed successfully.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Node.Split">
            <summary>
            Splits the octree into eight children.
            </summary>
        </member>
        <member name="M:Octree.PointOctree`1.Node.Merge">
            <summary>
            Merge all children into this node - the opposite of Split.
            Note: We only have to check one level down since a merge will never happen if the children already have children,
            since THAT won't happen unless there are already too many objects to merge.
            </summary>
        </member>
        <member name="M:Octree.PointOctree`1.Node.Encapsulates(Octree.BoundingBox,GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Checks if outerBounds encapsulates the given point.
            </summary>
            <param name="outerBounds">Outer bounds.</param>
            <param name="point">Point.</param>
            <returns>True if innerBounds is fully encapsulated by outerBounds.</returns>
        </member>
        <member name="M:Octree.PointOctree`1.Node.ShouldMerge">
            <summary>
            Checks if there are few enough objects in this node and its children that the children should all be merged into this.
            </summary>
            <returns>True there are less or the same amount of objects in this and its children than <see cref="F:Octree.PointOctree`1.Node.NumObjectsAllowed"/>.</returns>
        </member>
    </members>
</doc>
