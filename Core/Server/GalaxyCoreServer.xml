<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GalaxyCoreServer</name>
    </assembly>
    <members>
        <member name="T:GalaxyCoreServer.Api.ApprovalConnection">
            <summary>
            Unauthorized connection
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Api.ApprovalConnection.netConnection">
            <summary>
            Реальное соеденение
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Api.ApprovalConnection.Approve(GalaxyCoreCommon.BaseMessage,System.Int32,GalaxyCoreServer.Client,System.Object)">
            <summary>
            Allow server connection
            </summary>
            <param name="baseMessage">message (BaseMessage)</param>
            <param name="id">User ID</param>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.Api.ApprovalConnection.Approve(System.Int32,System.Byte[],GalaxyCoreServer.Client,System.Object)">
            <summary>
            Allow server connection
            </summary>
            <param name="data">Message (optional)</param>
            <param name="id">Client ID</param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.Api.ApprovalConnection.Deny(System.Byte,System.String)">
            <summary>
            Deny authorization
            </summary>
            <param name="err">error code (custom)</param>
            <param name="mes">the message sent to the client</param>
        </member>
        <member name="M:GalaxyCoreServer.Api.GalaxyChat.SendToInstance(GalaxyCoreServer.Instance,System.String,System.Int32)">
            <summary>
            Отправить сообщение чата всем в инстансе
            </summary>
            <param name="instance"></param>
            <param name="text"></param>
            <param name="sender"></param>
        </member>
        <member name="T:GalaxyCoreServer.Api.GalaxyEvents">
            <summary>
            Core public events
            </summary>
        </member>
        <member name="E:GalaxyCoreServer.Api.GalaxyEvents.OnGalaxyConnect">
            <summary>
            Client connected and requests authorization
            </summary>
        </member>
        <member name="E:GalaxyCoreServer.Api.GalaxyEvents.OnGalaxyRegistration">
            <summary>
            Client requests registration
            </summary>
        </member>
        <member name="E:GalaxyCoreServer.Api.GalaxyEvents.OnGalaxyDisconnect">
            <summary>
            Client disconnected
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Api.GalaxyEvents.CallOnGalaxyDisconnect(GalaxyCoreServer.Client)">
             <summary>
            Client disconnected
             </summary>
             <param name="clientConnection">Client</param>
        </member>
        <member name="E:GalaxyCoreServer.Api.GalaxyEvents.OnGalaxyInstanceCreate">
            <summary>
            Called when creating a new instance to override logic
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Api.GalaxyEvents.CallOnGalaxyInstanceCreate(System.Byte,System.Byte[],GalaxyCoreServer.Client)">
            <summary>
            Вызов события переопределения инстанса
            </summary>
            <param name="type"></param>
            <param name="data"></param>
            <param name="clientConnection"></param>
            <returns></returns>
        </member>
        <member name="E:GalaxyCoreServer.Api.GalaxyEvents.OnNetEntityInstantiate">
            <summary>
            Called when any network entity is created
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Api.GalaxyOctree">
            <summary>
            Октодрево для быстрого поиска ближайших объектов
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Api.GalaxyOctree.inited">
            <summary>
            инициализированно ли древо
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Api.GalaxyOctree.Init(System.Single,System.Single)">
            <summary>
            Инициализация древа
            </summary>
            <param name="startSize">Стартовый размер древа</param>
            <param name="minNodeSize">Минимальный размер нода</param>
        </member>
        <member name="M:GalaxyCoreServer.Api.GalaxyOctree.GetNearby(GalaxyCoreCommon.GalaxyVector3,System.Single)">
            <summary>
            Получить NetEntity в пределах указанной дистанции от точки
            </summary>
            <param name="pos">точка поиска</param>
            <param name="distance">дистанция</param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.Api.GalaxyOctree.AddEntity(GalaxyCoreServer.NetEntity)">
            <summary>
            Добавить сущность
            </summary>
            <param name="entity"></param>
        </member>
        <member name="M:GalaxyCoreServer.Api.GalaxyOctree.RemoveEntity(GalaxyCoreServer.NetEntity)">
            <summary>
            Добавить сущность
            </summary>
            <param name="entity"></param>
        </member>
        <member name="T:GalaxyCoreServer.Api.InstanceManager">
            <summary>
            Менеджер инстансов
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Api.InstanceManager.Create(System.String,System.Int32,System.Byte,System.Byte[],GalaxyCoreServer.Client,System.String,System.Boolean)">
            <summary>
            Creating a new instance
            </summary>
            <param name="name">Instance name</param>
            <param name="maxClients">Maximum clients (0 if unlimited)</param>
            <param name="type">Custom type (can be from 0 to 255)</param>
            <param name="data">User data</param>
            <param name="client">The client that requested the creation of the instance may be null if the request was not created by the client but, for example, by the server</param>
            <param name="password">Login Password</param>
            <param name="visible">is visible to other users</param>
        </member>
        <member name="M:GalaxyCoreServer.Api.InstanceManager.Create(GalaxyCoreServer.Instance)">
            <summary>
            Direct instantiation
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:GalaxyCoreServer.Api.InstanceManager.InstancesList(GalaxyCoreServer.Client)">
            <summary>
            Запрос информации о всех активных инстансах
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:GalaxyCoreServer.Api.InstanceManager.CloseInstance(GalaxyCoreServer.Instance)">
            <summary>
            Closing an instance
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:GalaxyCoreServer.Api.InstanceManager.Add(GalaxyCoreServer.Instance)">
            <summary>
            добавление инстанса в память
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:GalaxyCoreServer.Api.InstanceManager.Remove(GalaxyCoreServer.Instance)">
            <summary>
            удаление инстанса из памяти
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:GalaxyCoreServer.Api.InstanceManager.GetInstanceByID(System.Int32)">
            <summary>
            Get an instance by id
            </summary>
            <param name="id">ид инстанса</param>
            <returns>Вернет Instance или null если ничего нет</returns>
        </member>
        <member name="M:GalaxyCoreServer.Api.InstanceManager.GetAllInstances">
            <summary>
            Get All Instances
            Получить все инстансы
            </summary>
            <returns></returns>
        </member>
        <member name="T:GalaxyCoreServer.Api.NetEntityManager">
            <summary>
            Network Entity Manager
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Api.NetEntityManager.List">
            <summary>
            List of network objects
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Api.NetEntityManager.Count">
            <summary>
            Number of network entities in an instance
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Api.NetEntityManager.#ctor(GalaxyCoreServer.Instance)">
            <summary>
            Default constructor
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:GalaxyCoreServer.Api.NetEntityManager.GetNearby(GalaxyCoreCommon.GalaxyVector3,System.Single)">
            <summary>
            Getting a NetEntity array in a radius from a specified point
            </summary>
            <param name="pos">точка поиска</param>
            <param name="distance">Радиус</param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.Api.NetEntityManager.AddIgnoreList(GalaxyCoreServer.NetEntity)">
            <summary>
            добавляем энтити в список игнора сетевой видимости
            </summary>
            <param name="netEntity"></param>
        </member>
        <member name="M:GalaxyCoreServer.Api.NetEntityManager.RemoveIgnoreList(GalaxyCoreServer.NetEntity)">
            <summary>
            Удаляем энтити из списка игнора сетевой видимости
            </summary>
            <param name="netEntity"></param>
        </member>
        <member name="M:GalaxyCoreServer.Api.NetEntityManager.CreateNetEntity(GalaxyCoreServer.NetEntity)">
            <summary>
            Создание сетевой сущности со стороны сервера
            </summary>
            <param name="netEntity"></param>
        </member>
        <member name="M:GalaxyCoreServer.Api.NetEntityManager.RemoveNetEntity(System.Int32)">
            <summary>
            Удаление сетевой сущности
            </summary>
            <param name="netId"></param>
        </member>
        <member name="M:GalaxyCoreServer.Api.NetEntityManager.RemoveNetEntity(GalaxyCoreServer.NetEntity)">
            <summary>
            Удаление сетевой сущности
            </summary>
            <param name="entity">целевая сущность</param>
        </member>
        <member name="M:GalaxyCoreServer.Api.NetEntityManager.InMessage(System.Int32,System.Byte,System.Byte[],GalaxyCoreServer.Client)">
            <summary>
            Входящее сообщение для сетевого объекта
            </summary>
            <param name="netId"></param>
            <param name="externalCode"></param>
            <param name="data"></param>
            <param name="client"></param>
        </member>
        <member name="T:GalaxyCoreServer.Api.Statistic">
            <summary>
            Серверная статистика
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Api.Statistic.InMessages">
            <summary>
            Число входящих сообщений
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Api.Statistic.OutMessages">
            <summary>
            Число исходящих сообщений
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Api.Statistic.InTraffic">
            <summary>
            Входящий трафик в байтах
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Api.Statistic.QutTraffic">
            <summary>
            Исходящий трафик в байтах
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Api.Statistic.UserOnline">
            <summary>
            Число игроков онлайн
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Client">
            <summary>
            Client connection class
            Класс подключения клиента
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Client.Id">
            <summary>
            Client ID, set in Approval
            Ид клиента, задается в Approval
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Client.Name">
            <summary>
            Client's public name
            Публичное имя клиента
            </summary>             
        </member>
        <member name="F:GalaxyCoreServer.Client.netConnection">
            <summary>
            Реальное соеденение
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Client._netPeer">
            <summary>
            Дополнительная ссылка на пир
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Client.TimeConnected">
            <summary>
            Online in seconds
            Онлайн в секундах
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Client.Instanse">
            <summary>
            Link to the current client instance
            Ссылка на текущий инстант клиента
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Client.Statistic">
            <summary>
            Статистика
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Client.key">
            <summary>
            Сетевой ключик
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Client.synk">
            <summary>
            Синхронизировал ли клиент картину мира в текущем инстансе
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Client.Entities">
            <summary>
            Client-managed entity list
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Client.visibleEntitiesLastFrame">
            <summary>
            видимые энтити в данный момент
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Client.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Client.SetNetConnection(Lidgren.Network.NetConnection)">
            <summary>
            Internet connection installation
            Установка интернет соеденения
            </summary>
            <param name="netConnection"></param>
        </member>
        <member name="M:GalaxyCoreServer.Client.IsVisibleEntity(System.Int32)">
            <summary>
            Does the client see this entity
            </summary>
            <param name="netID"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.Client.SendMessage(System.Byte,GalaxyCoreCommon.BaseMessage,GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Send data to user
            Отправить сообщение пользователю
            </summary>
            <param name="code">Custom message code, for easy separation</param>
            <param name="message">Сообщение (наследник BaseMessage)</param>
            <param name="deliveryType">Delivery Type</param>
        </member>
        <member name="M:GalaxyCoreServer.Client.SendMessage(System.Byte,System.Byte[],GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Send data to user
            Отправить данные пользователю
            </summary>
            <param name="code">Custom message code, for easy separation</param>
            <param name="data">byte array</param>
            <param name="deliveryType">Delivery Type</param>
        </member>
        <member name="M:GalaxyCoreServer.Client.SendError(System.Byte)">
            <summary>
            Send an error message to the client
            Отправить клиенту сообщение об ошибке
            </summary>
            <param name="code">error code</param>    
        </member>
        <member name="M:GalaxyCoreServer.Client.Disconnect">
            <summary>
            Disable user
            Отключить пользователя
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Client.GetUserEntities">
            <summary>
            Get all client network entities
            Получить все сетевые сущности клиента
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.Client.GetBaseData">
            <summary>
            Additional data in baseInfoClient
            Дополнительные данные в baseInfoClient
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.Client.OnDisconnected">
            <summary>
            Called when the client disconnects
            Вызывается при отключении клиента
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.ClientStandard">
            <summary>
            Standard client
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.ClientStandard.OnDisconnected">
            <summary>
            
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Config">
            <summary>
            Server configuration class
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Config.IncomingMessage">
            <summary>
            You must specify a class that implements the processing of incoming messages
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Config.ServerName">
            <summary>
            Server name
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Config.ListenPort">
            <summary>
            Client connection port
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Config.SendBufferSize">
            <summary>
            Send buffer size
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Config.ReceiveBufferSize">
            <summary>
            Receive buffer size
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Config.PingInterval">
            <summary>
            Ping interval
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Config.ConnectionTimeout">
            <summary>
            Connection timeout (sec.)
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Config.AutoFlushSend">
            <summary>
            Automatic dispatch of message queue
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Config.TransmissionUnitMax">
            <summary>
            Maximum number of bytes to send in one packet, excluding ip, udp headers.
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Config.MtuAutoExpand">
            <summary>
            Enable if the server needs to send large messages to try to increase the maximum transmission block size
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Config.NetFrameRate">
            <summary>
            default frame rate
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.GalaxyCore">
            <summary>
            Сетевое ядро
            Network Kernel
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.GalaxyCore.Version">
            <summary>
            Core version
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.GalaxyCore.config">
            <summary>
            Base server config
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.GalaxyCore.networkCore">
            <summary>
            Основной экземпляр ядра
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.GalaxyCore.Statistic">
            <summary>
            Общая статистика
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.GalaxyCore.Clients">
            <summary>
            Менеджер клиентов
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.GalaxyCore.Instances">
            <summary>
            Менеджер по работе с инстансами
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.GalaxyCore.Start(GalaxyCoreServer.Config)">
            <summary>
            Запуск сетевого ядра
            Network Kernel Launch
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:GalaxyCoreServer.GalaxyCore.Stop">
            <summary>
            Остановка сетевого ядра
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.GalaxyVars">
            <summary>
            Synchronizing Variables
            Класс синхронизации переменных
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.GalaxyVars.AutoApplyRemoteData">
            <summary>
            Автоматически доверять данным от клиента
            </summary>
        </member>
        <member name="E:GalaxyCoreServer.GalaxyVars.OnChangedValue">
            <summary>
            Variable value changed
            Изменилось значение переменной
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.GalaxyVars.GetData(System.Byte)">
            <summary>
            Get a variable by id
            Получить переменную по ид
            </summary>
            <param name="varID">variable id</param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.GalaxyVars.GetAllVars">
            <summary>
            Получить полный список переменных для отправки
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.GalaxyVars.RegistrationClass(System.Object)">
            <summary>
            Registering a class to work with GalaxyVars
            Регистрация класса для работы с GalaxyVars
            </summary>
            <param name="target">class</param>
        </member>
        <member name="M:GalaxyCoreServer.GalaxyVars.Update">
            <summary>
            проверка на изменение переменных со стороны сервера
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.GalaxyVars.ForceSync">
            <summary>
            Force full data upload
            Принудительная отправка данных
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.IIncomingMessage">
            <summary>
            Интерфейс для работы с входящими сообщениями
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.IIncomingMessage.IncomingMessage(System.Byte,System.Byte[],GalaxyCoreServer.Client)">
            <summary>
            Входящее сообщение
            </summary>
            <param name="code">код сообщения</param>
            <param name="data">данные от клиента</param>
            <param name="clientConnection">подключение</param>
        </member>
        <member name="T:GalaxyCoreServer.Instance">
            <summary>
            The base class of the instance, serves as the basis for creating rooms, locations, and the like
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Instance.Time">
            <summary>
            Time
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Instance.Physics">
            <summary>
            Physical representation
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Instance.AutoUpdateClientsInfo">
            <summary>
            Automatic updating of information on clients about other clients
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Instance.FrameRate">
            <summary>
            Frame rate (ticks per second)
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Instance.AutoChangeOwner">
            <summary>
            Automatic owner assignment
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Instance.Clients">
            <summary>
            List of clients
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Instance.Entities">
            <summary>
            network entity manager
            </summary>      
        </member>
        <member name="F:GalaxyCoreServer.Instance.Type">
            <summary>
            Instance type
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Instance.Name">
            <summary>
            Instance name
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Instance.Id">
            <summary>
            Lies on the server
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Instance.Owner">
            <summary>
            instance owner
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Instance.MaxClients">
            <summary>
            Maximum players per instance
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Instance.AutoClose">
            <summary>
            Whether to close the instance when there are no players in it
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Instance.Password">
            <summary>
            Login Password
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Instance.Visible">
            <summary>
            Whether to display an instance in client lists
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Instance.Invoke(System.String,System.Single,System.Object[])">
            <summary>
            Calling a public method after a specified time
            </summary>
            <param name="methodName">method name</param>
            <param name="time">time</param>
            <param name="list">parameters</param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.InvokeRepeating(System.String,System.Single,System.Single,System.Object[])">
            <summary>
            Calling a method after a specified time with a specified repetition
            </summary>
            <param name="methodName">method name</param>
            <param name="time">time</param>
            <param name="repeat">repetition time</param>
            <param name="list">parameters</param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.CancelInvoke(System.String)">
            <summary>
            Delete the task of calling a method by name
            </summary>
            <param name="methodName">имя метода</param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.Close">
            <summary>
            Called when the instance is closed
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Instance.GetClientById(System.Int32)">
            <summary>
            Getting a client in an instance by Id
            </summary>
            <param name="clientId"></param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.Instance.SetFrameRate(System.Int32)">
            <summary>
            Set frame rate
            </summary>
            <param name="currentFrameRate">ticks per second</param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.CallOnUpdate">
            <summary>
            Вызывает обвновление всех сетевых сущностей в комнате
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Instance.Update">
            <summary>
            Network frame tick
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Instance.AddClient(GalaxyCoreServer.Client,System.Object)">
            <summary>
            Add client
            </summary>
            <param name="clientConnection">client</param>
            <param name="obj"> </param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.SussesIncoming(GalaxyCoreServer.Client)">
            <summary>
            Отправка клиенту сообщения об успешном входе в инстанс
            </summary>
            <param name="clientConnection"></param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.Start">
            <summary>
            Called when an instance is created
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Instance.IncomingClient(GalaxyCoreServer.Client)">
            <summary>
            Called when a player enters an instance
            </summary>
            <param name="clientConnection">Client</param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.OutgoingClient(GalaxyCoreServer.Client)">
            <summary>
            The client left the room
            </summary>
            <param name="clientConnection"></param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.RemoveClient(GalaxyCoreServer.Client)">
            <summary>
            Removing a client
            </summary>
            <param name="clientConnection"></param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.ChangeOwner">
            <summary>
            Changing the owner of an instance to a random one
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Instance.ChangeOwner(GalaxyCoreServer.Client)">
            <summary>
            Transfer owner rights
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.GetUsersBaseInfo(GalaxyCoreServer.Client)">
            <summary>
            Ответ на запрос списка пользователей в инстансе
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.RemoveClientEntities(GalaxyCoreServer.Client)">
            <summary>
            Remove all client network entities
            </summary>
            <param name="clientConnection"></param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.InMessage(System.Byte,System.Byte[],GalaxyCoreServer.Client)">
            <summary>
            Custom forwarding a message to an instance
            </summary>
            <param name="code"></param>
            <param name="data"></param>
            <param name="clientConnection"></param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.SendMessageToAll(System.Byte,GalaxyCoreCommon.BaseMessage,GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Send a message to all users in the room
            </summary>
            <param name="code">message code</param>
            <param name="message"> </param>
            <param name="deliveryType">delivery method</param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.SendMessageToAll(System.Byte,System.Byte[],GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Send a message to all users in the room
            </summary>
            <param name="code">message code</param>
            <param name="data"> </param>
            <param name="deliveryType">delivery method</param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.SendInternalMessageToAll(System.Byte,System.Byte,System.Byte[],GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Внутреннаяя отправка сообщения
            </summary>
            <param name="internalCode"></param>
            <param name="externalCode"></param>
            <param name="data"></param>
            <param name="deliveryType"></param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.SendInternalMessageToAllExcept(GalaxyCoreServer.Client,System.Byte,System.Byte,System.Byte[],GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Внутреннаяя отправка сообщения всем кроме
            </summary>
            <param name="clientConnection"></param>
            <param name="internalCode"></param>
            <param name="externalCode"></param>
            <param name="data"></param>
            <param name="deliveryType"></param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.SendMessageToAllExcept(GalaxyCoreServer.Client,System.Byte,System.Byte[],GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Send a message to all users in the room except the selected one
            </summary>
            <param name="clientConnection">The connection that we exclude from the mailing list</param>
            <param name="code">код сообщения</param>
            <param name="data">данные</param>
            <param name="deliveryType">способ доставки</param>
        </member>
        <member name="M:GalaxyCoreServer.Instance.InstanceInfo">
            <summary>
            Getting user data for a request (list of instances)
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.Instance.SyncWorld(GalaxyCoreServer.Client)">
            <summary>
            отправить клиенту полное текущее состояние инстанса
            </summary>
            <param name="clientConnection"></param>
        </member>
        <member name="M:GalaxyCoreServer.InstanceFramerOctree.GenerateTransformMessageByIgnoreVisible(System.UInt32)">
            <summary>
            генерация фрейма для объектов игнорирующих сетевую видимость
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.InstanceOpenWorld">
            <summary>
            Реализация инстанса для больших миров
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.InstanceOpenWorld.#ctor">
            <summary>
            базовый конструктор
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.InstanceOpenWorldOctree">
            <summary>
            Инстанс с сетевой видимостью
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.InstanceOpenWorldOctree.VisibleDistance">
            <summary>
            Максимальная сетевая видимость
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.InstanceStandard">
            <summary>
            Стандартная реализация инстанса 
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.InstanceStandard.OutgoingClient(GalaxyCoreServer.Client)">
            <summary>
            Клиент вышел из инстанса
            </summary>
            <param name="clientConnection"></param>
        </member>
        <member name="M:GalaxyCoreServer.InstanceStandard.Close">
            <summary>
            Инстанс был закрыт
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.InstanceStandard.IncomingClient(GalaxyCoreServer.Client)">
            <summary>
            В инстанс вошел новый клиент
            </summary>
            <param name="clientConnection"></param>
        </member>
        <member name="M:GalaxyCoreServer.InstanceStandard.Start">
            <summary>
            Инстанс запустился
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.InstanceStandard.InMessage(System.Byte,System.Byte[],GalaxyCoreServer.Client)">
            <summary>
            Пришло новое сообщение в инстанс
            </summary>
            <param name="code"></param>
            <param name="data"></param>
            <param name="clientConnection"></param>
        </member>
        <member name="T:GalaxyCoreServer.InstanceTime">
            <summary>
            Instance Times View
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.InstanceTime.DeltaTime">
            <summary>
            Elapsed time since the last tick (Update) (in seconds)
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.InstanceTime.Time">
            <summary>
            Time in seconds since instance launch
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Log">
            <summary>
            Логирование
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Log.DelegateOnLogDebug">
            <summary>
            
            </summary>
            <param name="publisher"></param>
            <param name="message"></param>
        </member>
        <member name="E:GalaxyCoreServer.Log.OnLogDebug">
            <summary>
            Лог Debug
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Log.Debug(System.String,System.String)">
            <summary>
            Debug
            </summary>
            <param name="publisher">Кто вызвал</param>
            <param name="message">Сообщение</param>
        </member>
        <member name="T:GalaxyCoreServer.Log.DelegateOnLogInfo">
            <summary>
            
            </summary>
            <param name="publisher"></param>
            <param name="message"></param>
        </member>
        <member name="E:GalaxyCoreServer.Log.OnLogInfo">
            <summary>
            Лог Info
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Log.Info(System.String,System.String)">
            <summary>
            Info
            </summary>
            <param name="publisher">Кто вызвал</param>
            <param name="message">Сообщение</param>
        </member>
        <member name="T:GalaxyCoreServer.Log.DelegateOnLogWarning">
            <summary>
            
            </summary>
            <param name="publisher"></param>
            <param name="message"></param>
        </member>
        <member name="E:GalaxyCoreServer.Log.OnLogWarning">
            <summary>
            Лог предупреждение
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Log.Warning(System.String,System.String)">
            <summary>
            Warning
            </summary>
            <param name="publisher">Кто вызвал</param>
            <param name="message">Сообщение</param>
        </member>
        <member name="T:GalaxyCoreServer.Log.DelegateOnLogError">
            <summary>
            
            </summary>
            <param name="publisher"></param>
            <param name="message"></param>
        </member>
        <member name="E:GalaxyCoreServer.Log.OnLogError">
            <summary>
            Лог предупреждение
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Log.Error(System.String,System.String)">
            <summary>
            Error
            </summary>
            <param name="publisher">Кто вызвал</param>
            <param name="message">Сообщение</param>
        </member>
        <member name="T:GalaxyCoreServer.Managers.InvokeManager">
            <summary>
            Deferred Task Manager
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Managers.InvokeManager._tasks">
            <summary>
            task list
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.NetEntity">
            <summary>
            Server-side implementation of a network entity
            Серверная реализация сетевой сущности
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.NetEntity.IsStatic">
            <summary>
            Is the object static
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.NetEntity.OwnerClient">
            <summary>
            Owner's client class reference (can be null)
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetEntity.LossOwner">
            <summary>
            Loss of owner logic
            Логика при потере владельца
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.NetEntity.PrefabName">
            <summary>
            Network entity name (usually used to match with a prefab)
            Имя сетевой сущности (как правило служит для сопоставления с префабом)
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.NetEntity.localId">
            <summary>
            Local id (assigned automatically and serves only for correct initialization)
            Локальный ид (назначается автоматически и служит только для корректности инициализации)
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.NetEntity.NetId">
            <summary>
            Network ID (assigned automatically)
            Сетевой ид (назначается автоматически)
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.NetEntity.OwnerClientId">
            <summary>
            Entity owner id (if 0 then this is a server entity)
            Ид владельца сущьности (если 0 то это серверная сущность)
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetEntity.Instance">
            <summary>
            Link to the current instance
            Ссылка на текущий инстанс
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetEntity.Physics">
            <summary>
            Physical representation
            Физическое представление
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetEntity.transform">
            <summary>
            Transform
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetEntity.initData">
            <summary>
            Extended initialization data
            Расширенные данные инициализации
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetEntity.GalaxyVars">
            <summary>
             Synchronizing Variables
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetEntity.IgnoreNetVisible">
            <summary>
            The entity ignores network visibility (always visible)
            Сущность игнорирует сетевую видимость (виден всегда)
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetEntity.searchRangeVisible">
            <summary>
            search range of visible objects
            дальность поиска видимых объектов
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.NetEntity.OctreeThreshold">
            <summary>
            Range threshold causing coordinates update in the search tree
            Порог дальности вызывающий обновлении координат в древе поиска
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.#ctor(GalaxyCoreServer.Instance,GalaxyCoreCommon.GalaxyVector3,GalaxyCoreCommon.GalaxyQuaternion,GalaxyCoreServer.NetEntityAutoSync)">
            <summary>
            Creating a network entity
            Создание сетевой сущности
            </summary>
            <param name="instance">target instance</param>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.ChangeOwner(GalaxyCoreServer.Client)">
            <summary>
            Change entity owner
            Сменить владельца сущности
            </summary>
            <param name="client">new owner (if null, the server becomes the owner)</param>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.ChangeOwnerRandom">
            <summary>
            Replacing the owner with the client with the fewest active entities
            Замена владельца на клиента с наименьшим числом активных сущностей
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.Start">
            <summary>
            Called when the object is fully initialized
            Вызывается при полной инициализации объекта
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.OnDestroy">
            <summary>
            Called when an entity is deleted
            Вызывается при удалении сущности
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.Destory">
            <summary>
            Delete network object
            Удалить сетевой объект
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.Update">
            <summary>
            Network frame tick
            Тик сетевого кадра
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.InMessage(System.Byte,System.Byte[],GalaxyCoreServer.Client)">
            <summary>
            New incoming message
            Новое входящее сообщение
            </summary>
            <param name="externalCode">custom code</param>
            <param name="data"></param>
            <param name="clientSender">message sender</param>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.SendMessage(System.Byte,GalaxyCoreCommon.BaseMessage,GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Sending a message to all instances of a given object
            </summary>
            <param name="code">custom code</param>
            <param name="message"></param>
            <param name="deliveryType">delivery method</param>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.SendMessage(System.Byte,System.Byte[],GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Sending a message to all instances of a given object
            </summary>
            <param name="code">custom cod</param>
            <param name="data"> </param>
            <param name="deliveryType">delivery method</param>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.SendMessageExcept(GalaxyCoreServer.Client,System.Byte,GalaxyCoreCommon.BaseMessage,GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Send a message to all instances of this object except for the specified client
            </summary>
            <param name="client">excluded client</param>
            <param name="code">custom code</param>
            <param name="message"> </param>
            <param name="deliveryType">delivery method</param>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.SendMessageExcept(GalaxyCoreServer.Client,System.Byte,System.Byte[],GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Send a message to all instances of this object except for the specified client
            </summary>
            <param name="client">excluded client</param>
            <param name="code">custom code</param>
            <param name="data"> </param>
            <param name="deliveryType">delivery method</param>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.SendToOwner(System.Byte,System.Byte[],GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Send a message to the owner of the entity
            </summary>
            <param name="code"></param>
            <param name="data"></param>
            <param name="deliveryType"></param>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.SendMessageByOctoVisible(System.Byte,GalaxyCoreCommon.BaseMessage,GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Send a message to all users who see this entity
            </summary>
            <param name="code">message code</param>
            <param name="message"> </param>
            <param name="deliveryType">delivery method</param>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.SendMessageByOctoVisible(System.Byte,System.Byte[],GalaxyCoreCommon.GalaxyDeliveryType)">
            <summary>
            Send a message to all users who see this entity
            </summary>
            <param name="code">message code</param>
            <param name="data"> </param>
            <param name="deliveryType">delivery method</param>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.Invoke(System.String,System.Single,System.Object[])">
            <summary>
            Вызов публичного метода через указанное время
            </summary>
            <param name="name">Имя метода</param>
            <param name="time">время</param>
            <param name="list">набор параметров</param>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.InvokeRepeating(System.String,System.Single,System.Single,System.Object[])">
            <summary>
            Вызов метода через указанное время с указанным повторением
            </summary>
            <param name="name">Имя метода</param>
            <param name="time">время</param>
            <param name="repeat">время повторения</param>
            <param name="list">набор параметров</param>
        </member>
        <member name="M:GalaxyCoreServer.NetEntity.CancelInvoke(System.String)">
            <summary>
            Удалить задачу вызова метода по имени
            </summary>
            <param name="name">имя метода</param>
        </member>
        <member name="T:GalaxyCoreServer.NetEntityLossOwnerLogic">
            <summary>
            Loss of owner logic
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetEntityLossOwnerLogic.destroy">
            <summary>
            Destroy on loss of owner
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetEntityLossOwnerLogic.setServer">
            <summary>
            Change owner to server
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetEntityLossOwnerLogic.setRandomClient">
            <summary>
            Transfer to a random client
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.NetEntityStandard">
            <summary>
            default implementation of network entity
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.NetTransform">
            <summary>
            Transform
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetTransform.AutoApplyRemoteTransform">
            <summary>
            Automatically apply coordinates received from the client
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.NetTransform.SyncType">
            <summary>
            Auto sync mode
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.NetTransform.ApplyRemoteTransform">
            <summary>
            Apply transform values received from the client within the current frame
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Network.ClientStatistic">
            <summary>
            Client statistics
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Network.ClientStatistic.#ctor">
            <summary>
            базовый конструктор
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Network.ClientStatistic.SetStatisticMessage(System.Byte,System.UInt32)">
            <summary>
            Add to statistics
            </summary>
            <param name="code">код сообщения</param>
            <param name="lenght">размер сообщения</param>
        </member>
        <member name="M:GalaxyCoreServer.Network.ClientStatistic.GetCount(System.Byte)">
            <summary>
            Get the number of messages by code
            </summary>
            <param name="code">Custom message code</param>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.Network.ClientStatistic.GetBytes(System.Byte)">
            <summary>
            Get the number of bytes transferred 
            </summary>
            <param name="code">Custom message code</param>
            <returns></returns>
        </member>
        <member name="T:GalaxyCoreServer.Network.ConnectionApproval">
            <summary>
            Класс отвечающий за пакеты авторизации и регистрации
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Network.ConnectionManager">
            <summary>
            Account manager
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Network.ConnectionManager.Count">
            <summary>
            Number of customers online
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Network.ConnectionManager.#ctor">
            <summary>
             
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Network.ConnectionManager.Add(GalaxyCoreServer.Client,System.Object)">
            <summary>
            Add custom connection
            </summary>
            <param name="connection"></param>
            <param name="customData"></param>
        </member>
        <member name="M:GalaxyCoreServer.Network.ConnectionManager.Remove(GalaxyCoreServer.Client)">
            <summary>
            Delete user connection
            </summary>
            <param name="connection"></param>      
        </member>
        <member name="M:GalaxyCoreServer.Network.ConnectionManager.TryGetClientById(System.Int32,GalaxyCoreServer.Client@)">
            <summary>
            Get client bu id
            </summary>
            <param name="clientId"></param>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="T:GalaxyCoreServer.Network.ConnectionsManager">
            <summary>
            Менеджер учета клиентских соеденений
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Network.Delegates">
            <summary>
            Server delegates
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Network.Delegates.DelegateOnGalaxyConnect">
            <summary>
            Authorization request
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Network.Delegates.DelegateOnGalaxyRegistration">
            <summary>
            Registration request
            </summary>
            <param name="approvalConnection"></param>
            <param name="data"></param>
        </member>
        <member name="T:GalaxyCoreServer.Network.Delegates.DelegateOnGalaxyDisconnect">
            <summary>
            Disconnect
            </summary>
            <param name="clientConnection">подключение клиента</param>
        </member>
        <member name="T:GalaxyCoreServer.Network.Delegates.DelegateOnGalaxyInstanceCreate">
            <summary>
            Instance creation
            </summary>
            <param name="type"></param>      
            <param name="data"></param>
            <param name="clientConnection">подключение клиента</param>
            <returns></returns>
        </member>
        <member name="T:GalaxyCoreServer.Network.Delegates.DelegateOnNetEntityInstantiate">
            <summary>
            Creating a network entity
            </summary>
            <param name="name"></param>
            <param name="data"></param>
            <param name="clientConnection"></param>
            <returns></returns>
        </member>
        <member name="T:GalaxyCoreServer.Network.Delegates.DelegateOnCollisionEnter">
            <summary>
            Collision of two bodies
            Произошло столкновение
            </summary>
            <param name="collision"></param>
        </member>
        <member name="M:GalaxyCoreServer.Network.IncomingMessage.DataMessage(Lidgren.Network.NetIncomingMessage)">
            <summary>
            Пользовательское сообщение
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:GalaxyCoreServer.Network.IncomingMessage.InternalMessage(System.Byte,System.Byte,System.Byte[],GalaxyCoreServer.Client)">
            <summary>
            Пришло внутреннее сообщение
            </summary>
            <param name="internalCode"></param>
            <param name="externalCode"></param>
            <param name="data"></param>
            <param name="client"></param>
        </member>
        <member name="T:GalaxyCoreServer.Network.NetworkCore">
            <summary>
            Класс сетевого ядра
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Network.NetworkCore._netServer">
            <summary>
            Экземпляр лидгрен сервера
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Network.NetworkCore._netConfig">
            <summary>
            Базовый лидгрен конфигуратор
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Network.NetworkCore._inputStream">
            <summary>
            Основной поток входящих сообщений
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Network.NetworkCore._streamWork">
            <summary>
            Продолжать ли работу потока
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Network.NetworkCore._networkStream">
            <summary>
            экземпляр основного сепаратора
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Network.NetworkCore.SendGroupMessage(Lidgren.Network.NetBuffer,System.Collections.Generic.IList{Lidgren.Network.NetConnection},GalaxyCoreCommon.GalaxyDeliveryType,System.Int32)">
            <summary>
            Отправка группового сообщения
            </summary>
            <param name="buffer"></param>
            <param name="clients"></param>
            <param name="deliveryMethod"></param>
            <param name="chennal"></param>
        </member>
        <member name="M:GalaxyCoreServer.Network.NetworkCore.Flush">
            <summary>
            ПРинудительная отправка буфера
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Network.NetworkCore.Stop">
            <summary>
            Остановка сетевого потока
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Network.NetworkStream">
            <summary>
            Класс входящего потока
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Network.NetworkStream.approval">
            <summary>
            Обработчик авторизации / регистрации
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Network.NetworkStream.incomingMessage">
            <summary>
            Обработчик входящих пользовательских сообщений
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Network.NetworkStream.IncomingMessage(Lidgren.Network.NetIncomingMessage)">
            <summary>
            Первичная обработка входящих пакетов
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:GalaxyCoreServer.Physics.ColliderBox">
            <summary>
            Box коллайдер
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Physics.ColliderBox.#ctor(GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Создание коллайдера
            </summary>
            <param name="size">размер коллайдера</param>
        </member>
        <member name="M:GalaxyCoreServer.Physics.ColliderCapsule.#ctor(System.Single,System.Single)">
            <summary>
            Создание коллайдера
            </summary>
            <param name="radius">радиус</param>
        </member>
        <member name="M:GalaxyCoreServer.Physics.ColliderSphere.#ctor(System.Single)">
            <summary>
            Создание коллайдера
            </summary>
            <param name="radius">радиус</param>
        </member>
        <member name="T:GalaxyCoreServer.Physics.Collision">
            <summary>
            Description of the collision of two physical bodies
            Описание столкновения двух физических тел
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.Collision.Point">
            <summary>
            Collision Point in World Space
            Точка столкновения в мировом пространстве
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.Collision.Normal">
            <summary>
            Collision direction
            Направление столкновения
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.Collision.Tag">
            <summary>
            Collider tag
            Тег коллайдера
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.Collision.NetEntity">
            <summary>
            The entity with which the collision occurred. It may be null if a collision occurred with a static collider.
            Сущность с которой произошло столкновение. Может быть null если столкновение произошло с статическим коллайдером.
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Physics.PhysEntity">
            <summary>
            Physical representation for netEntity
            Физическое представление для netEntity
            </summary>
        </member>
        <member name="E:GalaxyCoreServer.Physics.PhysEntity.OnCollisionEnter">
            <summary>
            Collision of two bodies
            Произошло столкновение
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.PhysEntity.Material">
            <summary>
            Physical material
            Физический материал
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Physics.PhysEntity.Mass">
            <summary>
            Mass
            Масса объекта
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Physics.PhysEntity.IsKinematic">
            <summary>
            Is the object static in the physical world
            Статичен ли объект в физическом мире
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Physics.PhysEntity.isCollisionListener">
            <summary>
            Есть ли подписчики на коллизию
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Physics.PhysEntity.velocity">
            <summary>
            Linear acceleration of an object
            Линейное ускорение объекта
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Physics.PhysEntity.useGravity">
            <summary>
            Does gravity affect an object
            Действует ли гравитация на объект
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Physics.PhysEntity.AddForce(GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Apply directed force
            </summary>
            <param name="vector3"></param>
        </member>
        <member name="M:GalaxyCoreServer.Physics.PhysEntity.AddTorque(GalaxyCoreCommon.GalaxyVector3)">
            <summary>
            Physical rotation
            </summary>
            <param name="vector3"></param>
        </member>
        <member name="M:GalaxyCoreServer.Physics.PhysEntity.CallOnCollisionEnter(GalaxyCoreServer.Physics.Collision)">
            <summary>
            Вызвать событие коллизии
            </summary>
            <param name="collision"></param>
        </member>
        <member name="M:GalaxyCoreServer.Physics.PhysEntity.Activate(GalaxyCoreServer.Physics.ColliderBox)">
            <summary>
            Physics activation
            </summary>
            <param name="collider">Box collider</param>
        </member>
        <member name="M:GalaxyCoreServer.Physics.PhysEntity.Activate(GalaxyCoreServer.Physics.ColliderSphere)">
            <summary>
            Physics activation
            </summary>
            <param name="collider">ColliderSphere</param>
        </member>
        <member name="M:GalaxyCoreServer.Physics.PhysEntity.Activate(GalaxyCoreServer.Physics.ColliderCapsule)">
            <summary>
            Physics activation
            </summary>
            <param name="collider">ColliderCapsule</param>
        </member>
        <member name="M:GalaxyCoreServer.Physics.PhysEntity.ApplyPhys">
            <summary>
            Apply physical calculations
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Physics.PhysMaterial.DynamicFriction">
            <summary>
            Dynamic Friction
            Динамические трение
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Physics.PhysMaterial.staticFriction">
            <summary>
            Static Friction
            трение в покое
            </summary>
        </member>
        <member name="P:GalaxyCoreServer.Physics.PhysMaterial.bounciness">
            <summary>
            Bounciness
            отскок
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Physics.PhysMaterial.SetPreset(GalaxyCoreServer.Physics.PhysMaterialPreset)">
            <summary>
            Set material presset
            Установить настройки из прессета
            </summary>
            <param name="preset"></param>
        </member>
        <member name="T:GalaxyCoreServer.Physics.PhysMaterialPreset">
            <summary>
            Physical material
            Физический материал
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.PhysMaterialPreset.DynamicFriction">
            <summary>
            Dynamic Friction
            Динамические трение
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.PhysMaterialPreset.StaticFriction">
            <summary>
            Static Friction
            трение в покое
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.PhysMaterialPreset.Bounciness">
            <summary>
            Bounciness
            отскок
            </summary>
        </member>
        <member name="T:GalaxyCoreServer.Physics.PhysWorld">
            <summary>
            Представление физического мира внутри инстанса.
            Representation of the real world inside an instance.
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.PhysWorld.MultiThread">
            <summary>
            Whether to use multithreaded mode
            Использовать ли многопоточный режим
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Physics.PhysWorld.#ctor(GalaxyCoreServer.Instance)">
            <summary>
            Default constructor
            Дефолт конструктор
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Physics.PhysWorld.Activate(System.String)">
            <summary>
            Активация физического движка
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Physics.PhysWorld.RayCast(GalaxyCoreCommon.GalaxyVector3,GalaxyCoreCommon.GalaxyVector3,GalaxyCoreServer.Physics.RaycastHit@)">
            <summary>
            Рейкаст бесконечной длинны
            </summary>
            <param name="start">от куда начинается луч</param>
            <param name="direction">направление луча (цель-точка старта) </param>
            <param name="hit">Класс информации о результатах каста</param>
            <returns></returns>
        </member>
        <member name="T:GalaxyCoreServer.Physics.RaycastHit">
            <summary>
            Результат работы RayCast
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.RaycastHit.Entity">
            <summary>
            Сетевая сущность в которую уперся луч, может быть null если луч попал в статический коллайдер
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.RaycastHit.Tag">
            <summary>
            Тег объекта которого коснулся луч
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.RaycastHit.Point">
            <summary>
            Точка в которой остановился луч
            </summary>
        </member>
        <member name="F:GalaxyCoreServer.Physics.RaycastHit.HitNormal">
            <summary>
            Нормаль луча и объекта
            </summary>
        </member>
        <member name="M:GalaxyCoreServer.Physics.RaycastHit.SqlDistance">
            <summary>
            Квадрат длинны луча
            </summary>
            <returns></returns>
        </member>
        <member name="M:GalaxyCoreServer.Physics.RaycastHit.Distance">
            <summary>
            Длинна луча
            </summary>
            <returns></returns>
        </member>
        <member name="T:Jitter.Collision.CollisionIsland">
            <summary>
            Holds a list of bodies which are in contact with each other.
            </summary>
        </member>
        <member name="P:Jitter.Collision.CollisionIsland.Bodies">
            <summary>
            Gets a read only list of <see cref="T:Jitter.Dynamics.RigidBody"/> which are in contact with each other.
            </summary>
        </member>
        <member name="P:Jitter.Collision.CollisionIsland.Arbiter">
            <summary>
            Gets a read only list of <see cref="P:Jitter.Collision.CollisionIsland.Arbiter"/> which are involved in this island.
            </summary>
        </member>
        <member name="P:Jitter.Collision.CollisionIsland.Constraints">
            <summary>
            Gets a read only list of <see cref="T:Jitter.Dynamics.Constraints.Constraint"/> which are involved in this island.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Jitter.Collision.CollisionIsland.#ctor" -->
        <member name="M:Jitter.Collision.CollisionIsland.IsActive">
            <summary>
            Whether the island is active or not.
            </summary>
            <returns>Returns true if the island is active, otherwise false.</returns>
            <seealso cref="P:Jitter.Dynamics.RigidBody.IsActive"/>
        </member>
        <member name="M:Jitter.Collision.CollisionIsland.SetStatus(System.Boolean)">
            <summary>
            Sets the status of every body in this island to active or inactive.
            </summary>
            <param name="active">If true the island gets activated, if false it
            gets deactivated. </param>
            <seealso cref="P:Jitter.Dynamics.RigidBody.IsActive"/>
        </member>
        <member name="T:Jitter.Collision.IBroadphaseEntity">
            <summary>
            Entity of the Broadphase system. (Either a Softbody or a RigidBody)
            </summary>
        </member>
        <member name="T:Jitter.Collision.CollisionDetectedHandler">
            <summary>
            A delegate for collision detection.
            </summary>
            <param name="body1">The first body colliding with the second one.</param>
            <param name="body2">The second body colliding with the first one.</param>
            <param name="point">The point on body in world coordinates, where collision occur.</param>
            <param name="normal">The normal pointing from body2 to body1.</param>
            <param name="penetration">Estimated penetration depth of the collision.</param>
            <seealso cref="M:Jitter.Collision.CollisionSystem.Detect(System.Boolean)"/>
            <seealso cref="!:CollisionSystem.Detect(RigidBody,RigidBody)"/>
        </member>
        <member name="T:Jitter.Collision.PassedBroadphaseHandler">
            <summary>
            A delegate to inform the user that a pair of bodies passed the broadsphase
            system of the engine.
            </summary>
            <param name="body1">The first body.</param>
            <param name="body2">The second body.</param>
            <returns>If false is returned the collision information is dropped. The CollisionDetectedHandler
            is never called.</returns>
        </member>
        <member name="T:Jitter.Collision.PassedNarrowphaseHandler">
            <summary>
            A delegate to inform the user that a pair of bodies passed the narrowphase
            system of the engine.
            </summary>
            <param name="body1">The first body.</param>
            <param name="body2">The second body.</param>
            <returns>If false is returned the collision information is dropped. The CollisionDetectedHandler
            is never called.</returns>
        </member>
        <member name="T:Jitter.Collision.RaycastCallback">
            <summary>
            A delegate for raycasting.
            </summary>
            <param name="body">The body for which collision with the ray is detected.</param>
            <param name="normal">The normal of the collision.</param>
            <param name="fraction">The fraction which gives information where at the 
            ray the collision occured. The hitPoint is calculated by: rayStart+friction*direction.</param>
            <returns>If false is returned the collision information is dropped.</returns>
        </member>
        <member name="T:Jitter.Collision.CollisionSystem">
            <summary>
            CollisionSystem. Used by the world class to detect all collisions. 
            Can be used seperatly from the physics.
            </summary>
        </member>
        <member name="T:Jitter.Collision.CollisionSystem.BroadphasePair">
            <summary>
            Helper class which holds two bodies. Mostly used
            for multithreaded detection. (Passing this as
            the object parameter to ThreadManager.Instance.AddTask)
            </summary>
        </member>
        <member name="F:Jitter.Collision.CollisionSystem.BroadphasePair.Entity1">
            <summary>
            The first body.
            </summary>
        </member>
        <member name="F:Jitter.Collision.CollisionSystem.BroadphasePair.Entity2">
            <summary>
            The second body.
            </summary>
        </member>
        <member name="F:Jitter.Collision.CollisionSystem.BroadphasePair.Pool">
            <summary>
            A resource pool of Pairs.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystem.RemoveEntity(Jitter.Collision.IBroadphaseEntity)">
            <summary>
            Remove a body from the collision system. Removing a body from the world
            does automatically remove it from the collision system.
            </summary>
            <param name="body">The body to remove.</param>
            <returns>Returns true if the body was successfully removed, otherwise false.</returns>
        </member>
        <member name="M:Jitter.Collision.CollisionSystem.AddEntity(Jitter.Collision.IBroadphaseEntity)">
            <summary>
            Add a body to the collision system. Adding a body to the world
            does automatically add it to the collision system.
            </summary>
            <param name="body">The body to remove.</param>
        </member>
        <member name="E:Jitter.Collision.CollisionSystem.PassedBroadphase">
            <summary>
            Gets called when the broadphase system has detected possible collisions.
            </summary>
        </member>
        <member name="E:Jitter.Collision.CollisionSystem.CollisionDetected">
            <summary>
            Gets called when broad- and narrow phase collision were positive.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystem.#ctor">
            <summary>
            Initializes a new instance of the CollisionSystem.
            </summary>
        </member>
        <member name="P:Jitter.Collision.CollisionSystem.UseTriangleMeshNormal">
            <summary>
            If set to true the collision system uses the normal of
            the current colliding triangle as collision normal. This
            fixes unwanted behavior on triangle transitions.
            </summary>
        </member>
        <member name="P:Jitter.Collision.CollisionSystem.UseTerrainNormal">
            <summary>
            If set to true the collision system uses the normal of
            the current colliding triangle as collision normal. This
            fixes unwanted behavior on triangle transitions.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystem.Detect(Jitter.Collision.IBroadphaseEntity,Jitter.Collision.IBroadphaseEntity)">
            <summary>
            Checks two bodies for collisions using narrowphase.
            </summary>
            <param name="body1">The first body.</param>
            <param name="body2">The second body.</param>
        </member>
        <member name="M:Jitter.Collision.CollisionSystem.Raycast(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,Jitter.Collision.RaycastCallback,Jitter.Dynamics.RigidBody@,Jitter.LinearMath.JVector@,System.Single@)">
            <summary>
            Sends a ray (definied by start and direction) through the scene (all bodies added).
            NOTE: For performance reasons terrain and trianglemeshshape aren't checked
            against rays (rays are of infinite length). They are checked against segments
            which start at rayOrigin and end in rayOrigin + rayDirection.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystem.Raycast(Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector@,System.Single@)">
            <summary>
            Raycasts a single body. NOTE: For performance reasons terrain and trianglemeshshape aren't checked
            against rays (rays are of infinite length). They are checked against segments
            which start at rayOrigin and end in rayOrigin + rayDirection.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystem.CheckBothStaticOrInactive(Jitter.Collision.IBroadphaseEntity,Jitter.Collision.IBroadphaseEntity)">
            <summary>
            Checks the state of two bodies.
            </summary>
            <param name="entity1">The first body.</param>
            <param name="entity2">The second body.</param>
            <returns>Returns true if both are static or inactive.</returns>
        </member>
        <member name="M:Jitter.Collision.CollisionSystem.CheckBoundingBoxes(Jitter.Collision.IBroadphaseEntity,Jitter.Collision.IBroadphaseEntity)">
            <summary>
            Checks the AABB of the two rigid bodies.
            </summary>
            <param name="entity1">The first body.</param>
            <param name="entity2">The second body.</param>
            <returns>Returns true if an intersection occours.</returns>
        </member>
        <member name="M:Jitter.Collision.CollisionSystem.RaisePassedBroadphase(Jitter.Collision.IBroadphaseEntity,Jitter.Collision.IBroadphaseEntity)">
            <summary>
            Raises the PassedBroadphase event.
            </summary>
            <param name="entity1">The first body.</param>
            <param name="entity2">The second body.</param>
            <returns>Returns false if the collision information
            should be dropped</returns>
        </member>
        <member name="M:Jitter.Collision.CollisionSystem.RaiseCollisionDetected(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,System.Single)">
            <summary>
            Raises the CollisionDetected event.
            </summary>
            <param name="body1">The first body involved in the collision.</param>
            <param name="body2">The second body involved in the collision.</param>
            <param name="point">The collision point.</param>
            <param name="normal">The normal pointing to body1.</param>
            <param name="penetration">The penetration depth.</param>
        </member>
        <member name="M:Jitter.Collision.CollisionSystem.Detect(System.Boolean)">
            <summary>
            Tells the collisionsystem to check all bodies for collisions. Hook into the <see cref="E:Jitter.Collision.CollisionSystem.PassedBroadphase"/>
            and <see cref="E:Jitter.Collision.CollisionSystem.CollisionDetected"/> events to get the results.
            </summary>
            <param name="multiThreaded">If true internal multithreading is used.</param>
        </member>
        <member name="T:Jitter.Collision.CollisionSystemBrute">
            <summary>
            O(n^2) Broadphase detection. Every body is checked against each other body.
            This is pretty fast for scene containing just a few(~30) bodies.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemBrute.#ctor">
            <summary>
            Creates a new instance of the CollisionSystemBrute class.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemBrute.RemoveEntity(Jitter.Collision.IBroadphaseEntity)">
            <summary>
            Remove a body from the collision system. Removing a body from the world
            does automatically remove it from the collision system.
            </summary>
            <param name="body">The body to remove.</param>
            <returns>Returns true if the body was successfully removed, otherwise false.</returns>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemBrute.AddEntity(Jitter.Collision.IBroadphaseEntity)">
            <summary>
            Add a body to the collision system. Adding a body to the world
            does automatically add it to the collision system.
            </summary>
            <param name="body">The body to remove.</param>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemBrute.Detect(System.Boolean)">
            <summary>
            Tells the collisionsystem to check all bodies for collisions. Hook into the 
            <see cref="E:Jitter.Collision.CollisionSystem.PassedBroadphase"/>
            and <see cref="E:Jitter.Collision.CollisionSystem.CollisionDetected"/> events to get the results.
            </summary>
            <param name="multiThreaded">If true internal multithreading is used.</param>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemBrute.Raycast(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,Jitter.Collision.RaycastCallback,Jitter.Dynamics.RigidBody@,Jitter.LinearMath.JVector@,System.Single@)">
            <summary>
            Sends a ray (definied by start and direction) through the scene (all bodies added).
            NOTE: For performance reasons terrain and trianglemeshshape aren't checked
            against rays (rays are of infinite length). They are checked against segments
            which start at rayOrigin and end in rayOrigin + rayDirection.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemBrute.Raycast(Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector@,System.Single@)">
            <summary>
            Raycasts a single body. NOTE: For performance reasons terrain and trianglemeshshape aren't checked
            against rays (rays are of infinite length). They are checked against segments
            which start at rayOrigin and end in rayOrigin + rayDirection.
            </summary>
        </member>
        <member name="T:Jitter.Collision.CollisionSystemPersistentSAP">
            <summary>
            Full 3-Axis SweepAndPrune using persistent updates.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemPersistentSAP.OverlapPair.#ctor(Jitter.Collision.IBroadphaseEntity,Jitter.Collision.IBroadphaseEntity)">
            <summary>
            Initializes a new instance of the BodyPair class.
            </summary>
            <param name="entity1"></param>
            <param name="entity2"></param>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemPersistentSAP.OverlapPair.SetBodies(Jitter.Collision.IBroadphaseEntity,Jitter.Collision.IBroadphaseEntity)">
            <summary>
            Don't call this, while the key is used in the arbitermap.
            It changes the hashcode of this object.
            </summary>
            <param name="entity1">The first body.</param>
            <param name="entity2">The second body.</param>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemPersistentSAP.OverlapPair.Equals(System.Object)">
            <summary>
            Checks if two objects are equal.
            </summary>
            <param name="obj">The object to check against.</param>
            <returns>Returns true if they are equal, otherwise false.</returns>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemPersistentSAP.OverlapPair.GetHashCode">
            <summary>
            Returns the hashcode of the BodyPair.
            The hashcode is the same if an BodyPair contains the same bodies.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemPersistentSAP.Detect(System.Boolean)">
            <summary>
            Tells the collisionsystem to check all bodies for collisions. Hook into the
            <see cref="E:Jitter.Collision.CollisionSystem.PassedBroadphase"/>
            and <see cref="E:Jitter.Collision.CollisionSystem.CollisionDetected"/> events to get the results.
            </summary>
            <param name="multiThreaded">If true internal multithreading is used.</param>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemPersistentSAP.Raycast(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,Jitter.Collision.RaycastCallback,Jitter.Dynamics.RigidBody@,Jitter.LinearMath.JVector@,System.Single@)">
            <summary>
            Sends a ray (definied by start and direction) through the scene (all bodies added).
            NOTE: For performance reasons terrain and trianglemeshshape aren't checked
            against rays (rays are of infinite length). They are checked against segments
            which start at rayOrigin and end in rayOrigin + rayDirection.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemPersistentSAP.Raycast(Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector@,System.Single@)">
            <summary>
            Raycasts a single body. NOTE: For performance reasons terrain and trianglemeshshape aren't checked
            against rays (rays are of infinite length). They are checked against segments
            which start at rayOrigin and end in rayOrigin + rayDirection.
            </summary>
        </member>
        <member name="T:Jitter.Collision.CollisionSystemSAP">
            <summary>
            Uses single axis sweep and prune broadphase collision detection.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemSAP.#ctor">
            <summary>
            Creates a new instance of the CollisionSystemSAP class.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemSAP.RemoveEntity(Jitter.Collision.IBroadphaseEntity)">
            <summary>
            Remove a body from the collision system. Removing a body from the world
            does automatically remove it from the collision system.
            </summary>
            <param name="body">The body to remove.</param>
            <returns>Returns true if the body was successfully removed, otherwise false.</returns>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemSAP.AddEntity(Jitter.Collision.IBroadphaseEntity)">
            <summary>
            Add a body to the collision system. Adding a body to the world
            does automatically add it to the collision system.
            </summary>
            <param name="body">The body to remove.</param>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemSAP.Detect(System.Boolean)">
            <summary>
            Tells the collisionsystem to check all bodies for collisions. Hook into the
            <see cref="E:Jitter.Collision.CollisionSystem.PassedBroadphase"/>
            and <see cref="E:Jitter.Collision.CollisionSystem.CollisionDetected"/> events to get the results.
            </summary>
            <param name="multiThreaded">If true internal multithreading is used.</param>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemSAP.Raycast(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,Jitter.Collision.RaycastCallback,Jitter.Dynamics.RigidBody@,Jitter.LinearMath.JVector@,System.Single@)">
            <summary>
            Sends a ray (definied by start and direction) through the scene (all bodies added).
            NOTE: For performance reasons terrain and trianglemeshshape aren't checked
            against rays (rays are of infinite length). They are checked against segments
            which start at rayOrigin and end in rayOrigin + rayDirection.
            </summary>
        </member>
        <member name="M:Jitter.Collision.CollisionSystemSAP.Raycast(Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector@,System.Single@)">
            <summary>
            Raycasts a single body. NOTE: For performance reasons terrain and trianglemeshshape aren't checked
            against rays (rays are of infinite length). They are checked against segments
            which start at rayOrigin and end in rayOrigin + rayDirection.
            </summary>
        </member>
        <member name="T:Jitter.Collision.DynamicTreeNode`1">
            <summary>
            A node in the dynamic tree. The client does not interact with this directly.
            </summary>
        </member>
        <member name="F:Jitter.Collision.DynamicTreeNode`1.AABB">
            <summary>
            This is the fattened AABB.
            </summary>
        </member>
        <member name="T:Jitter.Collision.DynamicTree`1">
             <summary>
             A dynamic tree arranges data in a binary tree to accelerate
             queries such as volume queries and ray casts. Leafs are proxies
             with an AABB. In the tree we expand the proxy AABB by Settings.b2_fatAABBFactor
             so that the proxy AABB is bigger than the client object. This allows the client
             object to move by small amounts without triggering a tree update.
            
             Nodes are pooled and relocatable, so we use node indices rather than pointers.
             </summary>
        </member>
        <member name="M:Jitter.Collision.DynamicTree`1.#ctor(System.Single)">
            <summary>
            Constructing the tree initializes the node pool.
            </summary>
        </member>
        <member name="M:Jitter.Collision.DynamicTree`1.AddProxy(Jitter.LinearMath.JBBox@,`0)">
            <summary>
            Create a proxy in the tree as a leaf node. We return the index
            of the node instead of a pointer so that we can grow
            the node pool.        
            /// </summary>
            <param name="aabb">The aabb.</param>
            <param name="userData">The user data.</param>
            <returns>Index of the created proxy</returns>
        </member>
        <member name="M:Jitter.Collision.DynamicTree`1.RemoveProxy(System.Int32)">
            <summary>
            Destroy a proxy. This asserts if the id is invalid.
            </summary>
            <param name="proxyId">The proxy id.</param>
        </member>
        <member name="M:Jitter.Collision.DynamicTree`1.MoveProxy(System.Int32,Jitter.LinearMath.JBBox@,Jitter.LinearMath.JVector)">
            <summary>
            Move a proxy with a swepted AABB. If the proxy has moved outside of its fattened AABB,
            then the proxy is removed from the tree and re-inserted. Otherwise
            the function returns immediately.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="aabb">The aabb.</param>
            <param name="displacement">The displacement.</param>
            <returns>true if the proxy was re-inserted.</returns>
        </member>
        <member name="M:Jitter.Collision.DynamicTree`1.GetUserData(System.Int32)">
            <summary>
            Get proxy user data.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proxyId">The proxy id.</param>
            <returns>the proxy user data or 0 if the id is invalid.</returns>
        </member>
        <member name="M:Jitter.Collision.DynamicTree`1.GetFatAABB(System.Int32,Jitter.LinearMath.JBBox@)">
            <summary>
            Get the fat AABB for a proxy.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="fatAABB">The fat AABB.</param>
        </member>
        <member name="M:Jitter.Collision.DynamicTree`1.ComputeHeight">
            <summary>
            Compute the height of the binary tree in O(N) time. Should not be
            called often.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Jitter.Collision.DynamicTree`1.Query(System.Collections.Generic.List{System.Int32},Jitter.LinearMath.JBBox@)">
            <summary>
            Query an AABB for overlapping proxies. The callback class
            is called for each proxy that overlaps the supplied AABB.
            </summary>
            <param name="callback">The callback.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="T:Jitter.Collision.GJKCollide">
            <summary>
            GJK based implementation of Raycasting.
            </summary>
        </member>
        <member name="M:Jitter.Collision.GJKCollide.Pointcast(Jitter.Collision.ISupportMappable,Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            Checks if given point is within a shape.
            </summary>
            <param name="support">The supportmap implementation representing the shape.</param>
            <param name="orientation">The orientation of the shape.</param>
            <param name="invOrientation">The inverse orientation of the shape.</param>
            <param name="position">The position of the shape.</param>
            <param name="point">The point to check.</param>
            <returns>Returns true if the point is within the shape, otherwise false.</returns>
        </member>
        <member name="M:Jitter.Collision.GJKCollide.Raycast(Jitter.Collision.ISupportMappable,Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,System.Single@,Jitter.LinearMath.JVector@)">
            <summary>
            Checks if a ray definied through it's origin and direction collides
            with a shape.
            </summary>
            <param name="support">The supportmap implementation representing the shape.</param>
            <param name="orientation">The orientation of the shape.</param>
            <param name="invOrientation">The inverse orientation of the shape.</param>
            <param name="position">The position of the shape.</param>
            <param name="origin">The origin of the ray.</param>
            <param name="direction">The direction of the ray.</param>
            <param name="fraction">The fraction which gives information where at the 
            ray the collision occured. The hitPoint is calculated by: origin+friction*direction.</param>
            <param name="normal">The normal from the ray collision.</param>
            <returns>Returns true if the ray hit the shape, false otherwise.</returns>
        </member>
        <member name="T:Jitter.Collision.GJKCollide.VoronoiSimplexSolver">
            VoronoiSimplexSolver is an implementation of the closest point distance
            algorithm from a 1-4 points simplex to the origin.
            Can be used with GJK, as an alternative to Johnson distance algorithm. 
        </member>
        <member name="M:Jitter.Collision.GJKCollide.VoronoiSimplexSolver.PointOutsideOfPlane(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            Test if point p and d lie on opposite sides of plane through abc
        </member>
        <member name="T:Jitter.Collision.IslandManager">
            <summary>
            bodies have: connections - bodies they are connected with (via constraints or arbiters)
                         arbiters    - all arbiters they are involved
                         constraints - all constraints they are involved
                         
            static bodies dont have any connections. Think of the islands as a graph:
            nodes are the bodies, and edges are the connections
            </summary>
        </member>
        <member name="T:Jitter.Collision.TriangleVertexIndices">
            <summary>
            structure used to set up the mesh
            </summary>
        </member>
        <member name="F:Jitter.Collision.TriangleVertexIndices.I0">
            <summary>
            The first index.
            </summary>
        </member>
        <member name="F:Jitter.Collision.TriangleVertexIndices.I1">
            <summary>
            The second index.
            </summary>
        </member>
        <member name="F:Jitter.Collision.TriangleVertexIndices.I2">
            <summary>
            The third index.
            </summary>
        </member>
        <member name="M:Jitter.Collision.TriangleVertexIndices.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the TriangleVertexIndex structure.
            </summary>
            <param name="i0">The index of the first vertex.</param>
            <param name="i1">The index of the second vertex.</param>
            <param name="i2">The index of the third vertex.</param>
        </member>
        <member name="M:Jitter.Collision.TriangleVertexIndices.Set(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the values for the indices.
            </summary>
            <param name="i0">The index of the first vertex.</param>
            <param name="i1">The index of the second vertex.</param>
            <param name="i2">The index of the third vertex.</param>
        </member>
        <member name="T:Jitter.Collision.Octree">
            <summary>
            An octree implementation.
            </summary>
        </member>
        <member name="T:Jitter.Collision.Octree.EChild">
            <summary>
            endices into the children - P means "plus" and M means "minus" and the
            letters are xyz. So PPM means +ve x, +ve y, -ve z
            </summary>
        </member>
        <member name="P:Jitter.Collision.Octree.RootNodeBox">
            <summary>
            Gets the root node box containing the whole octree.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Octree.Clear">
            <summary>
            Clears the octree.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Octree.SetTriangles(System.Collections.Generic.List{Jitter.LinearMath.JVector},System.Collections.Generic.List{Jitter.Collision.TriangleVertexIndices})">
            <summary>
            Sets new triangles.
            </summary>
            <param name="positions">Vertices.</param>
            <param name="tris">Indices.</param>
        </member>
        <member name="M:Jitter.Collision.Octree.BuildOctree">
            <summary>
            Builds the octree.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Octree.#ctor(System.Collections.Generic.List{Jitter.LinearMath.JVector},System.Collections.Generic.List{Jitter.Collision.TriangleVertexIndices})">
            <summary>
            Initializes a new instance of the Octree class.
            </summary>
            <param name="positions">Vertices.</param>
            <param name="tris">Indices.</param>
        </member>
        <member name="M:Jitter.Collision.Octree.CreateAABox(Jitter.LinearMath.JBBox@,Jitter.Collision.Octree.EChild,Jitter.LinearMath.JBBox@)">
            <summary>
            Create a bounding box appropriate for a child, based on a parents AABox
            </summary>
            <param name="aabb"></param>
            <param name="child"></param>
            <param name="result"></param>
        </member>
        <member name="M:Jitter.Collision.Octree.GetTrianglesIntersectingtAABox(System.Collections.Generic.List{System.Int32},Jitter.LinearMath.JBBox@)">
            <summary>
            Returns all triangles which intersect the given axis aligned bounding box.
            </summary>
            <param name="triangles">The list to add the triangles to.</param>
            <param name="testBox">The axis alignes bounding box.</param>
            <returns></returns>
        </member>
        <member name="M:Jitter.Collision.Octree.GetTrianglesIntersectingRay(System.Collections.Generic.List{System.Int32},Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Returns all triangles which intersect the given axis aligned bounding box.
            </summary>
            <param name="rayOrigin"></param>
            <param name="rayDelta"></param>
            <param name="triangles"></param>
            <returns></returns>
        </member>
        <member name="M:Jitter.Collision.Octree.GetTriangleVertexIndex(System.Int32)">
            <summary>
            Gets the indices of a triangle by index.
            </summary>
            <param name="index">The index.</param>
            <returns>The indices of a triangle.</returns>
        </member>
        <member name="M:Jitter.Collision.Octree.GetVertex(System.Int32)">
            <summary>
            Gets a vertex from the vertex list.
            </summary>
            <param name="vertex">The index of the vertex</param>
            <returns></returns>
        </member>
        <member name="M:Jitter.Collision.Octree.GetVertex(System.Int32,Jitter.LinearMath.JVector@)">
            <summary>
            Gets a vertex from the vertex list.
            </summary>
            <param name="vertex">The index of the vertex</param>
            <param name="result"></param>
        </member>
        <member name="P:Jitter.Collision.Octree.NumTriangles">
            <summary>
            Gets the number of triangles within this octree.
            </summary>
        </member>
        <member name="T:Jitter.Collision.Shapes.BoxShape">
            <summary>
            A <see cref="T:Jitter.Collision.Shapes.Shape"/> representing a box.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.BoxShape.Size">
            <summary>
            The sidelength of the box.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.BoxShape.#ctor(Jitter.LinearMath.JVector)">
            <summary>
            Creates a new instance of the BoxShape class.
            </summary>
            <param name="size">The size of the box.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.BoxShape.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates a new instance of the BoxShape class.
            </summary>
            <param name="length">The length of the box.</param>
            <param name="height">The height of the box.</param>
            <param name="width">The width of the box</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.BoxShape.UpdateShape">
            <summary>
            This method uses the <see cref="T:Jitter.Collision.ISupportMappable"/> implementation
            to calculate the local bounding box, the mass, geometric center and 
            the inertia of the shape. In custom shapes this method should be overidden
            to compute this values faster.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.BoxShape.GetBoundingBox(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JBBox@)">
            <summary>
            Gets the axis aligned bounding box of the orientated shape.
            </summary>
            <param name="orientation">The orientation of the shape.</param>
            <param name="box">The axis aligned bounding box of the shape.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.BoxShape.CalculateMassInertia">
            <summary>
            This method uses the <see cref="T:Jitter.Collision.ISupportMappable"/> implementation
            to calculate the local bounding box, the mass, geometric center and 
            the inertia of the shape. In custom shapes this method should be overidden
            to compute this values faster.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.BoxShape.SupportMapping(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            SupportMapping. Finds the point in the shape furthest away from the given direction.
            Imagine a plane with a normal in the search direction. Now move the plane along the normal
            until the plane does not intersect the shape. The last intersection point is the result.
            </summary>
            <param name="direction">The direction.</param>
            <param name="result">The result.</param>
        </member>
        <member name="T:Jitter.Collision.Shapes.CapsuleShape">
            <summary>
            A <see cref="T:Jitter.Collision.Shapes.Shape"/> representing a capsule.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.CapsuleShape.Length">
            <summary>
            Gets or sets the length of the capsule (exclusive the round endcaps).
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.CapsuleShape.Radius">
            <summary>
            Gets or sets the radius of the endcaps.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.CapsuleShape.#ctor(System.Single,System.Single)">
            <summary>
            Create a new instance of the capsule.
            </summary>
            <param name="length">The length of the capsule (exclusive the round endcaps).</param>
            <param name="radius">The radius of the endcaps.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.CapsuleShape.CalculateMassInertia">
            <summary>
            
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.CapsuleShape.SupportMapping(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            SupportMapping. Finds the point in the shape furthest away from the given direction.
            Imagine a plane with a normal in the search direction. Now move the plane along the normal
            until the plane does not intersect the shape. The last intersection point is the result.
            </summary>
            <param name="direction">The direction.</param>
            <param name="result">The result.</param>
        </member>
        <member name="T:Jitter.Collision.Shapes.CompoundShape">
            <summary>
            A <see cref="T:Jitter.Collision.Shapes.Shape"/> representing a compoundShape consisting
            of several 'sub' shapes.
            </summary>
        </member>
        <member name="T:Jitter.Collision.Shapes.CompoundShape.TransformedShape">
            <summary>
            Holds a 'sub' shape and it's transformation. This TransformedShape can
            be added to the <see cref="T:Jitter.Collision.Shapes.CompoundShape"/>
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.CompoundShape.TransformedShape.Shape">
            <summary>
            The 'sub' shape.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.CompoundShape.TransformedShape.Position">
            <summary>
            The position of a 'sub' shape
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.CompoundShape.TransformedShape.InverseOrientation">
            <summary>
            The inverse orientation of the 'sub' shape.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.CompoundShape.TransformedShape.Orientation">
            <summary>
            The orienation of the 'sub' shape.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.CompoundShape.TransformedShape.#ctor(Jitter.Collision.Shapes.Shape,Jitter.LinearMath.JMatrix,Jitter.LinearMath.JVector)">
            <summary>
            Creates a new instance of the TransformedShape struct.
            </summary>
            <param name="shape">The shape.</param>
            <param name="orientation">The orientation this shape should have.</param>
            <param name="position">The position this shape should have.</param>
        </member>
        <member name="P:Jitter.Collision.Shapes.CompoundShape.Shapes">
            <summary>
            An array conaining all 'sub' shapes and their transforms.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.CompoundShape.#ctor(System.Collections.Generic.List{Jitter.Collision.Shapes.CompoundShape.TransformedShape})">
            <summary>
            Created a new instance of the CompountShape class.
            </summary>
            <param name="shapes">The 'sub' shapes which should be added to this 
            class.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.CompoundShape.DoShifting">
            <summary>
            Translate all subshapes in the way that the center of mass is
            in (0,0,0)
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.CompoundShape.SupportMapping(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            SupportMapping. Finds the point in the shape furthest away from the given direction.
            Imagine a plane with a normal in the search direction. Now move the plane along the normal
            until the plane does not intersect the shape. The last intersection point is the result.
            </summary>
            <param name="direction">The direction.</param>
            <param name="result">The result.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.CompoundShape.GetBoundingBox(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JBBox@)">
            <summary>
            Gets the axis aligned bounding box of the orientated shape. (Inlcuding all
            'sub' shapes)
            </summary>
            <param name="orientation">The orientation of the shape.</param>
            <param name="box">The axis aligned bounding box of the shape.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.CompoundShape.SetCurrentShape(System.Int32)">
            <summary>
            Sets the current shape. First <see cref="M:Jitter.Collision.Shapes.CompoundShape.Prepare(Jitter.LinearMath.JBBox@)"/> has to be called.
            After SetCurrentShape the shape immitates another shape.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Jitter.Collision.Shapes.CompoundShape.Prepare(Jitter.LinearMath.JBBox@)">
            <summary>
            Passes a axis aligned bounding box to the shape where collision
            could occour.
            </summary>
            <param name="box">The bounding box where collision could occur.</param>
            <returns>The upper index with which <see cref="M:Jitter.Collision.Shapes.CompoundShape.SetCurrentShape(System.Int32)"/> can be 
            called.</returns>
        </member>
        <member name="M:Jitter.Collision.Shapes.CompoundShape.Prepare(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            
            </summary>
            <param name="rayOrigin"></param>
            <param name="rayEnd"></param>
            <returns></returns>
        </member>
        <member name="T:Jitter.Collision.Shapes.ConeShape">
            <summary>
            A <see cref="T:Jitter.Collision.Shapes.Shape"/> representing a cone.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.ConeShape.Height">
            <summary>
            The height of the cone.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.ConeShape.Radius">
            <summary>
            The radius of the cone base.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.ConeShape.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a new instance of the ConeShape class.
            </summary>
            <param name="height">The height of the cone.</param>
            <param name="radius">The radius of the cone base.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.ConeShape.CalculateMassInertia">
            <summary>
            
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.ConeShape.SupportMapping(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            SupportMapping. Finds the point in the shape furthest away from the given direction.
            Imagine a plane with a normal in the search direction. Now move the plane along the normal
            until the plane does not intersect the shape. The last intersection point is the result.
            </summary>
            <param name="direction">The direction.</param>
            <param name="result">The result.</param>
        </member>
        <member name="T:Jitter.Collision.Shapes.ConvexHullShape">
            <summary>
            ConvexHullShape class.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.ConvexHullShape.#ctor(System.Collections.Generic.List{Jitter.LinearMath.JVector})">
            <summary>
            Constructor of ConvexHullShape class.
            </summary>
            <param name="vertices">A list containing all vertices defining
            the convex hull.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.ConvexHullShape.SupportMapping(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            SupportMapping. Finds the point in the shape furthest away from the given direction.
            Imagine a plane with a normal in the search direction. Now move the plane along the normal
            until the plane does not intersect the shape. The last intersection point is the result.
            </summary>
            <param name="direction">The direction.</param>
            <param name="result">The result.</param>
        </member>
        <member name="T:Jitter.Collision.Shapes.CylinderShape">
            <summary>
            A <see cref="T:Jitter.Collision.Shapes.Shape"/> representing a cylinder.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.CylinderShape.Height">
            <summary>
            Sets the height of the cylinder.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.CylinderShape.Radius">
            <summary>
            Sets the radius of the cylinder.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.CylinderShape.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a new instance of the CylinderShape class.
            </summary>
            <param name="height">The height of the cylinder.</param>
            <param name="radius">The radius of the cylinder.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.CylinderShape.CalculateMassInertia">
            <summary>
            
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.CylinderShape.SupportMapping(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            SupportMapping. Finds the point in the shape furthest away from the given direction.
            Imagine a plane with a normal in the search direction. Now move the plane along the normal
            until the plane does not intersect the shape. The last intersection point is the result.
            </summary>
            <param name="direction">The direction.</param>
            <param name="result">The result.</param>
        </member>
        <member name="T:Jitter.Collision.Shapes.Multishape">
            <summary>
            Represents a variable form of a shape.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.Multishape.SetCurrentShape(System.Int32)">
            <summary>
            Sets the current shape. First <see cref="M:Jitter.Collision.Shapes.Multishape.Prepare(Jitter.LinearMath.JBBox@)"/> has to be called.
            After SetCurrentShape the shape immitates another shape.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Jitter.Collision.Shapes.Multishape.Prepare(Jitter.LinearMath.JBBox@)">
            <summary>
            Passes a axis aligned bounding box to the shape where collision
            could occour.
            </summary>
            <param name="box">The bounding box where collision could occur.</param>
            <returns>The upper index with which <see cref="M:Jitter.Collision.Shapes.Multishape.SetCurrentShape(System.Int32)"/> can be 
            called.</returns>
        </member>
        <member name="M:Jitter.Collision.Shapes.Multishape.Prepare(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            
            </summary>
            <param name="rayOrigin"></param>
            <param name="rayDelta"></param>
            <returns></returns>
        </member>
        <member name="M:Jitter.Collision.Shapes.Multishape.GetBoundingBox(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JBBox@)">
            <summary>
            Gets the axis aligned bounding box of the orientated shape. This includes
            the whole shape.
            </summary>
            <param name="orientation">The orientation of the shape.</param>
            <param name="box">The axis aligned bounding box of the shape.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.Multishape.CalculateMassInertia">
            <summary>
            Calculates the inertia of a box with the sides of the multishape.
            </summary>
        </member>
        <member name="T:Jitter.Collision.Shapes.ShapeUpdatedHandler">
            <summary>
            Gets called when a shape changes one of the parameters.
            For example the size of a box is changed.
            </summary>
        </member>
        <member name="T:Jitter.Collision.Shapes.Shape">
            <summary>
            Represents the collision part of the RigidBody. A shape is mainly definied through it's supportmap.
            Shapes represent convex objects. Inherited classes have to overwrite the supportmap function.
            To implement you own shape: derive a class from <see cref="T:Jitter.Collision.Shapes.Shape"/>, implement the support map function
            and call 'UpdateShape' within the constructor. GeometricCenter, Mass, BoundingBox and Inertia is calculated numerically
            based on your SupportMap implementation.
            </summary>
        </member>
        <member name="E:Jitter.Collision.Shapes.Shape.ShapeUpdated">
            <summary>
            Gets called when the shape changes one of the parameters.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.Shape.#ctor">
            <summary>
            Creates a new instance of a shape.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.Shape.Inertia">
            <summary>
            Returns the inertia of the untransformed shape.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.Shape.Mass">
            <summary>
            Gets the mass of the shape. This is the volume. (density = 1)
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.Shape.RaiseShapeUpdated">
            <summary>
            Informs all listener that the shape changed.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.Shape.BoundingBox">
            <summary>
            The untransformed axis aligned bounding box of the shape.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.Shape.Tag">
            <summary>
            Allows to set a user defined value to the shape.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.Shape.MakeHull(System.Collections.Generic.List{Jitter.LinearMath.JVector}@,System.Int32)">
            <summary>
            Hull making.
            </summary>
            <remarks>Based/Completely from http://www.xbdev.net/physics/MinkowskiDifference/index.php
            I don't (100%) see why this should always work.
            </remarks>
            <param name="triangleList"></param>
            <param name="generationThreshold"></param>
        </member>
        <member name="M:Jitter.Collision.Shapes.Shape.GetBoundingBox(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JBBox@)">
            <summary>
            Uses the supportMapping to calculate the bounding box. Should be overidden
            to make this faster.
            </summary>
            <param name="orientation">The orientation of the shape.</param>
            <param name="box">The resulting axis aligned bounding box.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.Shape.UpdateShape">
            <summary>
            This method uses the <see cref="T:Jitter.Collision.ISupportMappable"/> implementation
            to calculate the local bounding box, the mass, geometric center and 
            the inertia of the shape. In custom shapes this method should be overidden
            to compute this values faster.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.Shape.CalculateMassInertia(Jitter.Collision.Shapes.Shape,Jitter.LinearMath.JVector@,Jitter.LinearMath.JMatrix@)">
            <summary>
            Calculates the inertia of the shape relative to the center of mass.
            </summary>
            <param name="shape"></param>
            <param name="centerOfMass"></param>
            <param name="inertia">Returns the inertia relative to the center of mass, not to the origin</param>
            <returns></returns>
        </member>
        <member name="M:Jitter.Collision.Shapes.Shape.CalculateMassInertia">
            <summary>
            Numerically calculates the inertia, mass and geometric center of the shape.
            This gets a good value for "normal" shapes. The algorithm isn't very accurate
            for very flat shapes. 
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.Shape.SupportMapping(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            SupportMapping. Finds the point in the shape furthest away from the given direction.
            Imagine a plane with a normal in the search direction. Now move the plane along the normal
            until the plane does not intersect the shape. The last intersection point is the result.
            </summary>
            <param name="direction">The direction.</param>
            <param name="result">The result.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.Shape.SupportCenter(Jitter.LinearMath.JVector@)">
            <summary>
            The center of the SupportMap.
            </summary>
            <param name="geomCenter">The center of the SupportMap.</param>
        </member>
        <member name="T:Jitter.Collision.Shapes.SphereShape">
            <summary>
            A <see cref="T:Jitter.Collision.Shapes.Shape"/> representing a sphere.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.SphereShape.Radius">
            <summary>
            The radius of the sphere.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.SphereShape.#ctor(System.Single)">
            <summary>
            Creates a new instance of the SphereShape class.
            </summary>
            <param name="radius">The radius of the sphere</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.SphereShape.SupportMapping(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            SupportMapping. Finds the point in the shape furthest away from the given direction.
            Imagine a plane with a normal in the search direction. Now move the plane along the normal
            until the plane does not intersect the shape. The last intersection point is the result.
            </summary>
            <param name="direction">The direction.</param>
            <param name="result">The result.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.SphereShape.GetBoundingBox(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JBBox@)">
            <summary>
            Calculates the bounding box of the sphere.
            </summary>
            <param name="orientation">The orientation of the shape.</param>
            <param name="box">The resulting axis aligned bounding box.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.SphereShape.CalculateMassInertia">
            <summary>
            
            </summary>
        </member>
        <member name="T:Jitter.Collision.Shapes.TerrainShape">
            <summary>
            Represents a terrain.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.TerrainShape.SphericalExpansion">
            <summary>
            Expands the triangles by the specified amount.
            This stabilizes collision detection for flat shapes.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.TerrainShape.#ctor(System.Single[0:,0:],System.Single,System.Single)">
            <summary>
            Initializes a new instance of the TerrainShape class.
            </summary>
            <param name="heights">An array containing the heights of the terrain surface.</param>
            <param name="scaleX">The x-scale factor. (The x-space between neighbour heights)</param>
            <param name="scaleZ">The y-scale factor. (The y-space between neighbour heights)</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.TerrainShape.SetCurrentShape(System.Int32)">
            <summary>
            Sets the current shape. First <see cref="M:Jitter.Collision.Shapes.TerrainShape.Prepare(Jitter.LinearMath.JBBox@)"/> has to be called.
            After SetCurrentShape the shape immitates another shape.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Jitter.Collision.Shapes.TerrainShape.Prepare(Jitter.LinearMath.JBBox@)">
            <summary>
            Passes a axis aligned bounding box to the shape where collision
            could occour.
            </summary>
            <param name="box">The bounding box where collision could occur.</param>
            <returns>The upper index with which <see cref="M:Jitter.Collision.Shapes.TerrainShape.SetCurrentShape(System.Int32)"/> can be 
            called.</returns>
        </member>
        <member name="M:Jitter.Collision.Shapes.TerrainShape.CalculateMassInertia">
            <summary>
            
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.TerrainShape.GetBoundingBox(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JBBox@)">
            <summary>
            Gets the axis aligned bounding box of the orientated shape. This includes
            the whole shape.
            </summary>
            <param name="orientation">The orientation of the shape.</param>
            <param name="box">The axis aligned bounding box of the shape.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.TerrainShape.SupportMapping(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            SupportMapping. Finds the point in the shape furthest away from the given direction.
            Imagine a plane with a normal in the search direction. Now move the plane along the normal
            until the plane does not intersect the shape. The last intersection point is the result.
            </summary>
            <param name="direction">The direction.</param>
            <param name="result">The result.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.TerrainShape.Prepare(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            
            </summary>
            <param name="rayOrigin"></param>
            <param name="rayDelta"></param>
            <returns></returns>
        </member>
        <member name="T:Jitter.Collision.Shapes.TriangleMeshShape">
            <summary>
            A <see cref="T:Jitter.Collision.Shapes.Shape"/> representing a triangleMesh.
            </summary>
        </member>
        <member name="P:Jitter.Collision.Shapes.TriangleMeshShape.SphericalExpansion">
            <summary>
            Expands the triangles by the specified amount.
            This stabilizes collision detection for flat shapes.
            </summary>
        </member>
        <member name="M:Jitter.Collision.Shapes.TriangleMeshShape.#ctor(Jitter.Collision.Octree)">
            <summary>
            Creates a new istance if the TriangleMeshShape class.
            </summary>
            <param name="octree">The octree which holds the triangles
            of a mesh.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.TriangleMeshShape.Prepare(Jitter.LinearMath.JBBox@)">
            <summary>
            Passes a axis aligned bounding box to the shape where collision
            could occour.
            </summary>
            <param name="box">The bounding box where collision could occur.</param>
            <returns>The upper index with which <see cref="M:Jitter.Collision.Shapes.TriangleMeshShape.SetCurrentShape(System.Int32)"/> can be 
            called.</returns>
        </member>
        <member name="M:Jitter.Collision.Shapes.TriangleMeshShape.Prepare(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            
            </summary>
            <param name="rayOrigin"></param>
            <param name="rayDelta"></param>
            <returns></returns>
        </member>
        <member name="M:Jitter.Collision.Shapes.TriangleMeshShape.SupportMapping(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            SupportMapping. Finds the point in the shape furthest away from the given direction.
            Imagine a plane with a normal in the search direction. Now move the plane along the normal
            until the plane does not intersect the shape. The last intersection point is the result.
            </summary>
            <param name="direction">The direction.</param>
            <param name="result">The result.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.TriangleMeshShape.GetBoundingBox(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JBBox@)">
            <summary>
            Gets the axis aligned bounding box of the orientated shape. This includes
            the whole shape.
            </summary>
            <param name="orientation">The orientation of the shape.</param>
            <param name="box">The axis aligned bounding box of the shape.</param>
        </member>
        <member name="M:Jitter.Collision.Shapes.TriangleMeshShape.SetCurrentShape(System.Int32)">
            <summary>
            Sets the current shape. First <see cref="M:Jitter.Collision.Shapes.TriangleMeshShape.Prepare(Jitter.LinearMath.JBBox@)"/> has to be called.
            After SetCurrentShape the shape immitates another shape.
            </summary>
            <param name="index"></param>
        </member>
        <member name="T:Jitter.Collision.ISupportMappable">
            <summary>
            The implementation of the ISupportMappable interface defines the form
            of a shape. <seealso cref="T:Jitter.Collision.GJKCollide"/> <seealso cref="T:Jitter.Collision.XenoCollide"/>
            </summary>
        </member>
        <member name="M:Jitter.Collision.ISupportMappable.SupportMapping(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            SupportMapping. Finds the point in the shape furthest away from the given direction.
            Imagine a plane with a normal in the search direction. Now move the plane along the normal
            until the plane does not intersect the shape. The last intersection point is the result.
            </summary>
            <param name="direction">The direction.</param>
            <param name="result">The result.</param>
        </member>
        <member name="M:Jitter.Collision.ISupportMappable.SupportCenter(Jitter.LinearMath.JVector@)">
            <summary>
            The center of the SupportMap.
            </summary>
            <param name="center"></param>
        </member>
        <member name="T:Jitter.Collision.XenoCollide">
            <summary>
            Implementation of the XenoCollide Algorithm by Gary Snethen. 
            Narrowphase collision detection highly optimized for C#.
            http://xenocollide.snethen.com/
            </summary>
        </member>
        <member name="M:Jitter.Collision.XenoCollide.Detect(Jitter.Collision.ISupportMappable,Jitter.Collision.ISupportMappable,Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,System.Single@)">
            <summary>
            Checks two shapes for collisions.
            </summary>
            <param name="support1">The SupportMappable implementation of the first shape to test.</param>
            <param name="support2">The SupportMappable implementation of the seconds shape to test.</param>
            <param name="orientation1">The orientation of the first shape.</param>
            <param name="orientation2">The orientation of the second shape.</param>
            <param name="position1">The position of the first shape.</param>
            <param name="position2">The position of the second shape</param>
            <param name="point">The pointin world coordinates, where collision occur.</param>
            <param name="normal">The normal pointing from body2 to body1.</param>
            <param name="penetration">Estimated penetration depth of the collision.</param>
            <returns>Returns true if there is a collision, false otherwise.</returns>
        </member>
        <member name="T:Jitter.Dynamics.ContactList">
            <summary>
            Represents a list of contacts. Every ContactList 
            has a maximum of four contacts.
            </summary>
        </member>
        <member name="T:Jitter.Dynamics.Arbiter">
            <summary>
            An arbiter holds all contact information of two bodies.
            The contacts are stored in the ContactList. There is a maximum
            of four contacts which can be added to an arbiter. The arbiter
            only keeps the best four contacts based on the area spanned by
            the contact points.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Arbiter.Body1">
            <summary>
            The first body.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Arbiter.Body2">
            <summary>
            The second body.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Arbiter.ContactList">
            <summary>
            The contact list containing all contacts of both bodies.
            </summary>
        </member>
        <member name="F:Jitter.Dynamics.Arbiter.Pool">
            <summary>
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Arbiter.#ctor(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody)">
            <summary>
            </summary>
            <param name="body1"></param>
            <param name="body2"></param>
        </member>
        <member name="M:Jitter.Dynamics.Arbiter.#ctor">
            <summary>
            Initializes a new instance of the Arbiter class.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Arbiter.Invalidate">
            <summary>
            Removes all contacts from this arbiter.
            The world will remove the arbiter automatically next frame
            or add new contacts.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Arbiter.AddContact(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,System.Single,Jitter.Dynamics.ContactSettings)">
            <summary>
            Adds a contact to the arbiter (threadsafe). No more than four contacts 
            are stored in the contactList. When adding a new contact
            to the arbiter the existing are checked and the best are kept.
            </summary>
            <param name="point1">Point on body1. In world space.</param>
            <param name="point2">Point on body2. In world space.</param>
            <param name="normal">The normal pointing to body2.</param>
            <param name="penetration">The estimated penetration depth.</param>
        </member>
        <member name="T:Jitter.Dynamics.ArbiterKey">
            <summary>
            For easy access, Arbiters are stored in a Hashtable(ArbiterMap). 
            To find the Arbiter fortwo RigidBodies, build an ArbiterKey for the two bodies
            and use it as the lookup key for the ArbiterMap.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.ArbiterKey.#ctor(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody)">
            <summary>
            Initializes a new instance of the ArbiterKey class.
            </summary>
            <param name="body1"></param>
            <param name="body2"></param>
        </member>
        <member name="M:Jitter.Dynamics.ArbiterKey.SetBodies(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody)">
            <summary>
            Don't call this, while the key is used in the arbitermap.
            It changes the hashcode of this object.
            </summary>
            <param name="body1">The first body.</param>
            <param name="body2">The second body.</param>
        </member>
        <member name="M:Jitter.Dynamics.ArbiterKey.Equals(System.Object)">
            <summary>
            Checks if two objects are equal.
            </summary>
            <param name="obj">The object to check against.</param>
            <returns>Returns true if they are equal, otherwise false.</returns>
        </member>
        <member name="M:Jitter.Dynamics.ArbiterKey.GetHashCode">
            <summary>
            Returns the hashcode of the ArbiterKey.
            The hashcode is the same if an ArbiterKey contains the same bodies.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Jitter.Dynamics.ArbiterMap">
            <summary>
            The ArbiterMap is a dictionary which stores all arbiters.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.ArbiterMap.#ctor">
            <summary>
            Initializes a new instance of the ArbiterMap class.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.ArbiterMap.LookUpArbiter(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody,Jitter.Dynamics.Arbiter@)">
            <summary>
            Gets an arbiter by it's bodies. Not threadsafe.
            </summary>
            <param name="body1">The first body.</param>
            <param name="body2">The second body.</param>
            <param name="arbiter">The arbiter which was found.</param>
            <returns>Returns true if the arbiter could be found, otherwise false.</returns>
        </member>
        <member name="M:Jitter.Dynamics.ArbiterMap.ContainsArbiter(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody)">
            <summary>
            Checks if an arbiter is within the arbiter map.
            </summary>
            <param name="body1">The first body.</param>
            <param name="body2">The second body.</param>
            <returns>Returns true if the arbiter could be found, otherwise false.</returns>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.IConstraint.Body2">
            <summary>
            Gets the second body. Can be null.
            </summary>
        </member>
        <member name="T:Jitter.Dynamics.Constraints.Constraint">
            <summary>
            A constraints forces a body to behave in a specific way.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.Constraint.Body1">
            <summary>
            Gets the first body. Can be null.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.Constraint.Body2">
            <summary>
            Gets the second body. Can be null.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.Constraint.#ctor(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody)">
            <summary>
            Constructor.
            </summary>
            <param name="body1">The first body which should get constrained. Can be null.</param>
            <param name="body2">The second body which should get constrained. Can be null.</param>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.Constraint.PrepareForIteration(System.Single)">
            <summary>
            Called once before iteration starts.
            </summary>
            <param name="timestep">The simulation timestep</param>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.Constraint.Iterate">
            <summary>
            Iteratively solve this constraint.
            </summary>
        </member>
        <member name="T:Jitter.Dynamics.Constraints.FixedAngle">
            <summary>
            The AngleConstraint constraints two bodies to always have the same relative
            orientation to each other. Combine the AngleConstraint with a PointOnLine
            Constraint to get a prismatic joint.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.FixedAngle.#ctor(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody)">
            <summary>
            Constraints two bodies to always have the same relative
            orientation to each other. Combine the AngleConstraint with a PointOnLine
            Constraint to get a prismatic joint.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.FixedAngle.Softness">
            <summary>
            Defines how big the applied impulses can get.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.FixedAngle.BiasFactor">
            <summary>
            Defines how big the applied impulses can get which correct errors.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.FixedAngle.PrepareForIteration(System.Single)">
            <summary>
            Called once before iteration starts.
            </summary>
            <param name="timestep">The 5simulation timestep</param>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.FixedAngle.Iterate">
            <summary>
            Iteratively solve this constraint.
            </summary>
        </member>
        <member name="T:Jitter.Dynamics.Constraints.PointOnLine">
            <summary>
            Constraints a point on a body to be fixed on a line
            which is fixed on another body.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.PointOnLine.#ctor(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Constraints a point on a body to be fixed on a line
            which is fixed on another body.
            </summary>
            <param name="body1"></param>
            <param name="body2"></param>
            <param name="lineStartPointBody1"></param>
            <param name="lineDirection"></param>
            <param name="pointBody2"></param>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.PointOnLine.Softness">
            <summary>
            Defines how big the applied impulses can get.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.PointOnLine.BiasFactor">
            <summary>
            Defines how big the applied impulses can get which correct errors.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.PointOnLine.PrepareForIteration(System.Single)">
            <summary>
            Called once before iteration starts.
            </summary>
            <param name="timestep">The simulation timestep</param>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.PointOnLine.Iterate">
            <summary>
            Iteratively solve this constraint.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.PointOnPoint.#ctor(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector)">
            <summary>
            Initializes a new instance of the DistanceConstraint class.
            </summary>
            <param name="body1">The first body.</param>
            <param name="body2">The second body.</param>
            <param name="anchor1">The anchor point of the first body in world space. 
            The distance is given by the initial distance between both anchor points.</param>
            <param name="anchor2">The anchor point of the second body in world space.
            The distance is given by the initial distance between both anchor points.</param>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.PointOnPoint.Softness">
            <summary>
            Defines how big the applied impulses can get.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.PointOnPoint.BiasFactor">
            <summary>
            Defines how big the applied impulses can get which correct errors.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.PointOnPoint.PrepareForIteration(System.Single)">
            <summary>
            Called once before iteration starts.
            </summary>
            <param name="timestep">The 5simulation timestep</param>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.PointOnPoint.Iterate">
            <summary>
            Iteratively solve this constraint.
            </summary>
        </member>
        <member name="T:Jitter.Dynamics.Constraints.PointPointDistance">
            <summary>
            The distance between two given points on two bodies will not
            exceed a value.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.PointPointDistance.#ctor(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Initializes a new instance of the DistanceConstraint class.
            </summary>
            <param name="body1">The first body.</param>
            <param name="body2">The second body.</param>
            <param name="anchor1">The anchor point of the first body in world space. 
            The distance is given by the initial distance between both anchor points.</param>
            <param name="anchor2">The anchor point of the second body in world space.
            The distance is given by the initial distance between both anchor points.</param>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.PointPointDistance.Distance">
            <summary>
            
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.PointPointDistance.Behavior">
            <summary>
            
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.PointPointDistance.LocalAnchor1">
            <summary>
            The anchor point of body1 in local (body) coordinates.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.PointPointDistance.LocalAnchor2">
            <summary>
            The anchor point of body2 in local (body) coordinates.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.PointPointDistance.Softness">
            <summary>
            Defines how big the applied impulses can get.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.PointPointDistance.BiasFactor">
            <summary>
            Defines how big the applied impulses can get which correct errors.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.PointPointDistance.PrepareForIteration(System.Single)">
            <summary>
            Called once before iteration starts.
            </summary>
            <param name="timestep">The 5simulation timestep</param>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.PointPointDistance.Iterate">
            <summary>
            Iteratively solve this constraint.
            </summary>
        </member>
        <member name="T:Jitter.Dynamics.Constraints.SingleBody.FixedAngle">
            <summary>
            The body stays at a fixed angle relative to
            world space.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.SingleBody.FixedAngle.#ctor(Jitter.Dynamics.RigidBody)">
            <summary>
            Constraints two bodies to always have the same relative
            orientation to each other. Combine the AngleConstraint with a PointOnLine
            Constraint to get a prismatic joint.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.SingleBody.FixedAngle.Softness">
            <summary>
            Defines how big the applied impulses can get.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.SingleBody.FixedAngle.BiasFactor">
            <summary>
            Defines how big the applied impulses can get which correct errors.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.SingleBody.FixedAngle.PrepareForIteration(System.Single)">
            <summary>
            Called once before iteration starts.
            </summary>
            <param name="timestep">The 5simulation timestep</param>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.SingleBody.FixedAngle.Iterate">
            <summary>
            Iteratively solve this constraint.
            </summary>
        </member>
        <member name="T:Jitter.Dynamics.Constraints.SingleBody.PointOnLine">
            <summary>
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.SingleBody.PointOnLine.#ctor(Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Initializes a new instance of the WorldLineConstraint.
            </summary>
            <param name="body">The body of the constraint.</param>
            <param name="localAnchor">The anchor point on the body in local (body)
            coordinates.</param>
            <param name="lineDirection">The axis defining the line in world space.</param>/param>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.SingleBody.PointOnLine.Anchor">
            <summary>
            The anchor point of the body in world space.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.SingleBody.PointOnLine.Axis">
            <summary>
            The axis defining the line of the constraint.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.SingleBody.PointOnLine.Softness">
            <summary>
            Defines how big the applied impulses can get.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.SingleBody.PointOnLine.BiasFactor">
            <summary>
            Defines how big the applied impulses can get which correct errors.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.SingleBody.PointOnLine.PrepareForIteration(System.Single)">
            <summary>
            Called once before iteration starts.
            </summary>
            <param name="timestep">The simulation timestep</param>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.SingleBody.PointOnLine.Iterate">
            <summary>
            Iteratively solve this constraint.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.SingleBody.PointOnPoint.#ctor(Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector)">
            <summary>
            Initializes a new instance of the DistanceConstraint class.
            </summary>
            <param name="body1">The first body.</param>
            <param name="body2">The second body.</param>
            <param name="anchor1">The anchor point of the first body in world space. 
            The distance is given by the initial distance between both anchor points.</param>
            <param name="anchor2">The anchor point of the second body in world space.
            The distance is given by the initial distance between both anchor points.</param>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.SingleBody.PointOnPoint.Softness">
            <summary>
            Defines how big the applied impulses can get.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.SingleBody.PointOnPoint.Anchor">
            <summary>
            The anchor point in the world.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Constraints.SingleBody.PointOnPoint.BiasFactor">
            <summary>
            Defines how big the applied impulses can get which correct errors.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.SingleBody.PointOnPoint.PrepareForIteration(System.Single)">
            <summary>
            Called once before iteration starts.
            </summary>
            <param name="timestep">The 5simulation timestep</param>
        </member>
        <member name="M:Jitter.Dynamics.Constraints.SingleBody.PointOnPoint.Iterate">
            <summary>
            Iteratively solve this constraint.
            </summary>
        </member>
        <member name="T:Jitter.Dynamics.Contact">
            <summary>
            </summary>
        </member>
        <member name="F:Jitter.Dynamics.Contact.Pool">
            <summary>
            A contact resource pool.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Contact.Body1">
            <summary>
            The first body involved in the contact.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Contact.Body2">
            <summary>
            The second body involved in the contact.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Contact.Penetration">
            <summary>
            The penetration of the contact.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Contact.Position1">
            <summary>
            The collision position in world space of body1.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Contact.Position2">
            <summary>
            The collision position in world space of body2.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Contact.Tangent">
            <summary>
            The contact tangent.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Contact.Normal">
            <summary>
            The contact normal.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Contact.CalculateRelativeVelocity">
            <summary>
            Calculates relative velocity of body contact points on the bodies.
            </summary>
            <param name="relVel">The relative velocity of body contact points on the bodies.</param>
        </member>
        <member name="M:Jitter.Dynamics.Contact.Iterate">
            <summary>
            Solves the contact iteratively.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Contact.UpdatePosition">
            <summary>
            The points in wolrd space gets recalculated by transforming the
            local coordinates. Also new penetration depth is estimated.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Contact.ApplyImpulse(Jitter.LinearMath.JVector@)">
            <summary>
            An impulse is applied an both contact points.
            </summary>
            <param name="impulse">The impulse to apply.</param>
        </member>
        <member name="M:Jitter.Dynamics.Contact.PrepareForIteration(System.Single)">
            <summary>
            PrepareForIteration has to be called before <see cref="M:Jitter.Dynamics.Contact.Iterate"/>.
            </summary>
            <param name="timestep">The timestep of the simulation.</param>
        </member>
        <member name="M:Jitter.Dynamics.Contact.Initialize(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,System.Single,System.Boolean,Jitter.Dynamics.ContactSettings)">
            <summary>
            Initializes a contact.
            </summary>
            <param name="body1">The first body.</param>
            <param name="body2">The second body.</param>
            <param name="point1">The collision point in worldspace</param>
            <param name="point2">The collision point in worldspace</param>
            <param name="n">The normal pointing to body2.</param>
            <param name="penetration">The estimated penetration depth.</param>
        </member>
        <member name="M:Jitter.Dynamics.IConstraint.PrepareForIteration(System.Single)">
            <summary>
            Called once before iteration starts.
            </summary>
            <param name="timestep">The simulation timestep</param>
        </member>
        <member name="M:Jitter.Dynamics.IConstraint.Iterate">
            <summary>
            Iteratively solve this constraint.
            </summary>
        </member>
        <member name="T:Jitter.Dynamics.Joints.HingeJoint">
            <summary>
            Connects to bodies with a hinge joint.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Joints.HingeJoint.#ctor(Jitter.World,Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Initializes a new instance of the HingeJoint class.
            </summary>
            <param name="world">The world class where the constraints get added to.</param>
            <param name="body1">The first body connected to the second one.</param>
            <param name="body2">The second body connected to the first one.</param>
            <param name="position">The position in world space where both bodies get connected.</param>
            <param name="hingeAxis">The axis if the hinge.</param>
        </member>
        <member name="M:Jitter.Dynamics.Joints.HingeJoint.Activate">
            <summary>
            Adds the internal constraints of this joint to the world class.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Joints.HingeJoint.Deactivate">
            <summary>
            Removes the internal constraints of this joint from the world class.
            </summary>
        </member>
        <member name="T:Jitter.Dynamics.Joints.Joint">
            <summary>
            A joint is a collection of internally handled constraints.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.Joints.Joint.World">
            <summary>
            The world class to which the internal constraints
            should be added.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Joints.Joint.#ctor(Jitter.World)">
            <summary>
            Creates a new instance of the Joint class.
            </summary>
            <param name="world">The world class to which the internal constraints
            should be added.</param>
        </member>
        <member name="M:Jitter.Dynamics.Joints.Joint.Activate">
            <summary>
            Adds the internal constraints of this joint to the world class.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Joints.Joint.Deactivate">
            <summary>
            Removes the internal constraints of this joint from the world class.
            </summary>
        </member>
        <member name="T:Jitter.Dynamics.Joints.LimitedHingeJoint">
            <summary>
            Limited hinge joint.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Joints.LimitedHingeJoint.#ctor(Jitter.World,Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody,Jitter.LinearMath.JVector,Jitter.LinearMath.JVector,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the HingeJoint class.
            </summary>
            <param name="world">The world class where the constraints get added to.</param>
            <param name="body1">The first body connected to the second one.</param>
            <param name="body2">The second body connected to the first one.</param>
            <param name="position">The position in world space where both bodies get connected.</param>
            <param name="hingeAxis">The axis if the hinge.</param>
        </member>
        <member name="M:Jitter.Dynamics.Joints.LimitedHingeJoint.Activate">
            <summary>
            Adds the internal constraints of this joint to the world class.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.Joints.LimitedHingeJoint.Deactivate">
            <summary>
            Removes the internal constraints of this joint from the world class.
            </summary>
        </member>
        <member name="T:Jitter.Dynamics.RigidBody">
            <summary>
            The RigidBody class.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.IsParticle">
            <summary>
            If true, the body as no angular movement.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.RigidBody.#ctor(Jitter.Collision.Shapes.Shape,Jitter.Dynamics.Material)">
            <summary>
            Initializes a new instance of the RigidBody class.
            </summary>
            <param name="shape">The shape of the body.</param>
        </member>
        <member name="M:Jitter.Dynamics.RigidBody.#ctor(Jitter.Collision.Shapes.Shape,Jitter.Dynamics.Material,System.Boolean)">
            <summary>
            Initializes a new instance of the RigidBody class.
            </summary>
            <param name="shape">The shape of the body.</param>
            <param name="isParticle">If set to true the body doesn't rotate. 
            Also contacts are only solved for the linear motion part.</param>
        </member>
        <member name="M:Jitter.Dynamics.RigidBody.GetHashCode">
            <summary>
            Calculates a hashcode for this RigidBody.
            The hashcode should be unique as possible
            for every body.
            </summary>
            <returns>The hashcode.</returns>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.AllowDeactivation">
            <summary>
            If set to false the body will never be deactived by the
            world.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.BoundingBox">
            <summary>
            The axis aligned bounding box of the body.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.CollisionIsland">
            <summary>
            Gets the current collision island the body is in.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.IsActive">
            <summary>
            If set to false the velocity is set to zero,
            the body gets immediately freezed.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.RigidBody.ApplyImpulse(Jitter.LinearMath.JVector)">
            <summary>
            Applies an impulse on the center of the body. Changing
            linear velocity.
            </summary>
            <param name="impulse">Impulse direction and magnitude.</param>
        </member>
        <member name="M:Jitter.Dynamics.RigidBody.ApplyImpulse(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Applies an impulse on the specific position. Changing linear
            and angular velocity.
            </summary>
            <param name="impulse">Impulse direction and magnitude.</param>
            <param name="relativePosition">The position where the impulse gets applied
            in Body coordinate frame.</param>
        </member>
        <member name="M:Jitter.Dynamics.RigidBody.AddForce(Jitter.LinearMath.JVector)">
            <summary>
            Adds a force to the center of the body. The force gets applied
            the next time <see cref="M:Jitter.World.Step(System.Single,System.Boolean)"/> is called. The 'impact'
            of the force depends on the time it is applied to a body - so
            the timestep influences the energy added to the body.
            </summary>
            <param name="force">The force to add next <see cref="M:Jitter.World.Step(System.Single,System.Boolean)"/>.</param>
        </member>
        <member name="M:Jitter.Dynamics.RigidBody.AddForce(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Adds a force to the center of the body. The force gets applied
            the next time <see cref="M:Jitter.World.Step(System.Single,System.Boolean)"/> is called. The 'impact'
            of the force depends on the time it is applied to a body - so
            the timestep influences the energy added to the body.
            </summary>
            <param name="force">The force to add next <see cref="M:Jitter.World.Step(System.Single,System.Boolean)"/>.</param>
            <param name="pos">The position where the force is applied.</param>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.Torque">
            <summary>
            Returns the torque which acts this timestep on the body.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.Force">
            <summary>
            Returns the force which acts this timestep on the body.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.RigidBody.AddTorque(Jitter.LinearMath.JVector)">
            <summary>
            Adds torque to the body. The torque gets applied
            the next time <see cref="M:Jitter.World.Step(System.Single,System.Boolean)"/> is called. The 'impact'
            of the torque depends on the time it is applied to a body - so
            the timestep influences the energy added to the body.
            </summary>
            <param name="torque">The torque to add next <see cref="M:Jitter.World.Step(System.Single,System.Boolean)"/>.</param>
        </member>
        <member name="M:Jitter.Dynamics.RigidBody.SetMassProperties">
            <summary>
            By calling this method the shape inertia and mass is used.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.RigidBody.SetMassProperties(Jitter.LinearMath.JMatrix,System.Single,System.Boolean)">
            <summary>
            The engine used the given values for inertia and mass and ignores
            the shape mass properties.
            </summary>
            <param name="inertia">The inertia/inverse inertia of the untransformed object.</param>
            <param name="mass">The mass/inverse mass of the object.</param>
            <param name="setAsInverseValues">Sets the InverseInertia and the InverseMass
            to this values.</param>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.Tag">
            <summary>
            Allows to set a user defined value to the body.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.Shape">
            <summary>
            The shape the body is using.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.Inertia">
            <summary>
            The inertia currently used for this body.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.InverseInertia">
            <summary>
            The inverse inertia currently used for this body.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.LinearVelocity">
            <summary>
            The velocity of the body.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.AngularVelocity">
            <summary>
            The angular velocity of the body.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.Position">
            <summary>
            The current position of the body.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.Orientation">
            <summary>
            The current oriention of the body.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.IsStatic">
            <summary>
            If set to true the body can't be moved.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.InverseInertiaWorld">
            <summary>
            The inverse inertia tensor in world space.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.RigidBody.Mass">
            <summary>
            Setting the mass automatically scales the inertia.
            To set the mass indepedently from the mass use SetMassProperties.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.RigidBody.Update">
            <summary>
            Recalculates the axis aligned bounding box and the inertia
            values in world space.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.SoftBody.Spring.#ctor(Jitter.Dynamics.RigidBody,Jitter.Dynamics.RigidBody)">
            <summary>
            Initializes a new instance of the DistanceConstraint class.
            </summary>
            <param name="body1">The first body.</param>
            <param name="body2">The second body.</param>
            <param name="anchor1">The anchor point of the first body in world space. 
            The distance is given by the initial distance between both anchor points.</param>
            <param name="anchor2">The anchor point of the second body in world space.
            The distance is given by the initial distance between both anchor points.</param>
        </member>
        <member name="P:Jitter.Dynamics.SoftBody.Spring.Distance">
            <summary>
            
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.SoftBody.Spring.Behavior">
            <summary>
            
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.SoftBody.Spring.Softness">
            <summary>
            Defines how big the applied impulses can get.
            </summary>
        </member>
        <member name="P:Jitter.Dynamics.SoftBody.Spring.BiasFactor">
            <summary>
            Defines how big the applied impulses can get which correct errors.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.SoftBody.Spring.PrepareForIteration(System.Single)">
            <summary>
            Called once before iteration starts.
            </summary>
            <param name="timestep">The 5simulation timestep</param>
        </member>
        <member name="M:Jitter.Dynamics.SoftBody.Spring.Iterate">
            <summary>
            Iteratively solve this constraint.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.SoftBody.#ctor">
            <summary>
            Does create an empty body. Derive from SoftBody and fill 
            EdgeSprings,VertexBodies and Triangles by yourself.
            </summary>
        </member>
        <member name="M:Jitter.Dynamics.SoftBody.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Creates a 2D-Cloth. Connects Nearest Neighbours (4x, called EdgeSprings) and adds additional
            shear/bend constraints (4xShear+4xBend).
            </summary>
            <param name="sizeX"></param>
            <param name="sizeY"></param>
            <param name="scale"></param>
        </member>
        <member name="T:Jitter.IDebugDrawer">
            <summary>
            Interface for providing the possibility to get drawable debug information
            from an object.
            </summary>
        </member>
        <member name="T:Jitter.LinearMath.JBBox">
            <summary>
            Bounding Box defined through min and max vectors. Member
            of the math namespace, so every method has it's 'by reference'
            equivalent to speed up time critical math operations.
            </summary>
        </member>
        <member name="T:Jitter.LinearMath.JBBox.ContainmentType">
            <summary>
            Containment type used within the <see cref="T:Jitter.LinearMath.JBBox"/> structure.
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JBBox.ContainmentType.Disjoint">
            <summary>
            The objects don't intersect.
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JBBox.ContainmentType.Contains">
            <summary>
            One object is within the other.
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JBBox.ContainmentType.Intersects">
            <summary>
            The two objects intersect.
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JBBox.Min">
            <summary>
            The maximum point of the box.
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JBBox.Max">
            <summary>
            The minimum point of the box.
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JBBox.LargeBox">
            <summary>
            Returns the largest box possible.
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JBBox.SmallBox">
            <summary>
            Returns the smalltest box possible.
            </summary>
        </member>
        <member name="M:Jitter.LinearMath.JBBox.#ctor(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Constructor
            </summary>
            <param name="min">The minimum point of the box.</param>
            <param name="max">The maximum point of the box.</param>
        </member>
        <member name="M:Jitter.LinearMath.JBBox.InverseTransform(Jitter.LinearMath.JVector@,Jitter.LinearMath.JMatrix@)">
            <summary>
            Transforms the bounding box into the space given by orientation and position.
            </summary>
            <param name="position"></param>
            <param name="orientation"></param>
            <param name="result"></param>
        </member>
        <member name="M:Jitter.LinearMath.JBBox.Intersect1D(System.Single,System.Single,System.Single,System.Single,System.Single@,System.Single@)">
            <summary>
            Checks whether a point is inside, outside or intersecting
            a point.
            </summary>
            <returns>The ContainmentType of the point.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JBBox.Contains(Jitter.LinearMath.JVector)">
            <summary>
            Checks wether a point is within a box or not.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:Jitter.LinearMath.JBBox.Contains(Jitter.LinearMath.JVector@)">
            <summary>
            Checks whether a point is inside, outside or intersecting
            a point.
            </summary>
            <param name="point">A point in space.</param>
            <returns>The ContainmentType of the point.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JBBox.GetCorners(Jitter.LinearMath.JVector[])">
            <summary>
            Retrieves the 8 corners of the box.
            </summary>
            <returns>An array of 8 JVector entries.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JBBox.CreateFromPoints(Jitter.LinearMath.JVector[])">
            <summary>
            Expands a bounding box with the volume 0 by all points
            given.
            </summary>
            <param name="points">A array of JVector.</param>
            <returns>The resulting bounding box containing all points.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JBBox.Contains(Jitter.LinearMath.JBBox)">
            <summary>
            Checks whether another bounding box is inside, outside or intersecting
            this box. 
            </summary>
            <param name="box">The other bounding box to check.</param>
            <returns>The ContainmentType of the box.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JBBox.Contains(Jitter.LinearMath.JBBox@)">
            <summary>
            Checks whether another bounding box is inside, outside or intersecting
            this box. 
            </summary>
            <param name="box">The other bounding box to check.</param>
            <returns>The ContainmentType of the box.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JBBox.CreateMerged(Jitter.LinearMath.JBBox,Jitter.LinearMath.JBBox)">
            <summary>
            Creates a new box containing the two given ones.
            </summary>
            <param name="original">First box.</param>
            <param name="additional">Second box.</param>
            <returns>A JBBox containing the two given boxes.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JBBox.CreateMerged(Jitter.LinearMath.JBBox@,Jitter.LinearMath.JBBox@,Jitter.LinearMath.JBBox@)">
            <summary>
            Creates a new box containing the two given ones.
            </summary>
            <param name="original">First box.</param>
            <param name="additional">Second box.</param>
            <param name="result">A JBBox containing the two given boxes.</param>
        </member>
        <member name="T:Jitter.LinearMath.JConvexHull">
            <summary>
            Fast but dirty convex hull creation.
            advanced convex hull creation: http://www.qhull.org
            </summary>
        </member>
        <member name="T:Jitter.LinearMath.JMath">
            <summary>
            Contains some math operations used within Jitter.
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JMath.Pi">
            <summary>
            PI.
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JMath.Epsilon">
            <summary>
            A small value often used to decide if numeric 
            results are zero.
            </summary>
        </member>
        <member name="M:Jitter.LinearMath.JMath.Sqrt(System.Single)">
            <summary>
            Gets the square root.
            </summary>
            <param name="number">The number to get the square root from.</param>
            <returns></returns>
        </member>
        <member name="M:Jitter.LinearMath.JMath.Max(System.Single,System.Single)">
            <summary>
            Gets the maximum number of two values.
            </summary>
            <param name="val1">The first value.</param>
            <param name="val2">The second value.</param>
            <returns>Returns the largest value.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMath.Min(System.Single,System.Single)">
            <summary>
            Gets the minimum number of two values.
            </summary>
            <param name="val1">The first value.</param>
            <param name="val2">The second value.</param>
            <returns>Returns the smallest value.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMath.Max(System.Single,System.Single,System.Single)">
            <summary>
            Gets the maximum number of three values.
            </summary>
            <param name="val1">The first value.</param>
            <param name="val2">The second value.</param>
            <param name="val3">The third value.</param>
            <returns>Returns the largest value.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMath.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Returns a number which is within [min,max]
            </summary>
            <param name="value">The value to clamp.</param>
            <param name="min">The minimum value.</param>
            <param name="max">The maximum value.</param>
            <returns>The clamped value.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMath.Absolute(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JMatrix@)">
            <summary>
            Changes every sign of the matrix entry to '+'
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="result">The absolute matrix.</param>
        </member>
        <member name="T:Jitter.LinearMath.JMatrix">
            <summary>
            3x3 Matrix. Member of the math namespace, so every method
            has it's 'by reference' equivalent to speed up time critical
            math operations.
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JMatrix.M11">
            <summary>
            M11
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JMatrix.M12">
            <summary>
            M12
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JMatrix.M13">
            <summary>
            M13
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JMatrix.M21">
            <summary>
            M21
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JMatrix.M22">
            <summary>
            M22
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JMatrix.M23">
            <summary>
            M23
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JMatrix.M31">
            <summary>
            M31
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JMatrix.M32">
            <summary>
            M32
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JMatrix.M33">
            <summary>
            M33
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JMatrix.Identity">
            <summary>
            Identity matrix.
            </summary>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the matrix structure.
            </summary>
            <param name="m11">m11</param>
            <param name="m12">m12</param>
            <param name="m13">m13</param>
            <param name="m21">m21</param>
            <param name="m22">m22</param>
            <param name="m23">m23</param>
            <param name="m31">m31</param>
            <param name="m32">m32</param>
            <param name="m33">m33</param>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.Multiply(Jitter.LinearMath.JMatrix,Jitter.LinearMath.JMatrix)">
            <summary>
            Multiply two matrices. Notice: matrix multiplication is not commutative.
            </summary>
            <param name="matrix1">The first matrix.</param>
            <param name="matrix2">The second matrix.</param>
            <returns>The product of both matrices.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.Multiply(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JMatrix@)">
            <summary>
            Multiply two matrices. Notice: matrix multiplication is not commutative.
            </summary>
            <param name="matrix1">The first matrix.</param>
            <param name="matrix2">The second matrix.</param>
            <param name="result">The product of both matrices.</param>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.Add(Jitter.LinearMath.JMatrix,Jitter.LinearMath.JMatrix)">
            <summary>
            Matrices are added.
            </summary>
            <param name="matrix1">The first matrix.</param>
            <param name="matrix2">The second matrix.</param>
            <returns>The sum of both matrices.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.Add(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JMatrix@)">
            <summary>
            Matrices are added.
            </summary>
            <param name="matrix1">The first matrix.</param>
            <param name="matrix2">The second matrix.</param>
            <param name="result">The sum of both matrices.</param>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.Inverse(Jitter.LinearMath.JMatrix)">
            <summary>
            Calculates the inverse of a give matrix.
            </summary>
            <param name="matrix">The matrix to invert.</param>
            <returns>The inverted JMatrix.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.Inverse(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JMatrix@)">
            <summary>
            Calculates the inverse of a give matrix.
            </summary>
            <param name="matrix">The matrix to invert.</param>
            <param name="result">The inverted JMatrix.</param>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.Multiply(Jitter.LinearMath.JMatrix,System.Single)">
            <summary>
            Multiply a matrix by a scalefactor.
            </summary>
            <param name="matrix1">The matrix.</param>
            <param name="scaleFactor">The scale factor.</param>
            <returns>A JMatrix multiplied by the scale factor.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.Multiply(Jitter.LinearMath.JMatrix@,System.Single,Jitter.LinearMath.JMatrix@)">
            <summary>
            Multiply a matrix by a scalefactor.
            </summary>
            <param name="matrix1">The matrix.</param>
            <param name="scaleFactor">The scale factor.</param>
            <param name="result">A JMatrix multiplied by the scale factor.</param>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.CreateFromQuaternion(Jitter.LinearMath.JQuaternion)">
            <summary>
            Creates a JMatrix representing an orientation from a quaternion.
            </summary>
            <param name="quaternion">The quaternion the matrix should be created from.</param>
            <returns>JMatrix representing an orientation.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.CreateFromQuaternion(Jitter.LinearMath.JQuaternion@,Jitter.LinearMath.JMatrix@)">
            <summary>
            Creates a JMatrix representing an orientation from a quaternion.
            </summary>
            <param name="quaternion">The quaternion the matrix should be created from.</param>
            <param name="result">JMatrix representing an orientation.</param>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.Transpose(Jitter.LinearMath.JMatrix)">
            <summary>
            Creates the transposed matrix.
            </summary>
            <param name="matrix">The matrix which should be transposed.</param>
            <returns>The transposed JMatrix.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.Transpose(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JMatrix@)">
            <summary>
            Creates the transposed matrix.
            </summary>
            <param name="matrix">The matrix which should be transposed.</param>
            <param name="result">The transposed JMatrix.</param>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.op_Multiply(Jitter.LinearMath.JMatrix,Jitter.LinearMath.JMatrix)">
            <summary>
            Multiplies two matrices.
            </summary>
            <param name="value1">The first matrix.</param>
            <param name="value2">The second matrix.</param>
            <returns>The product of both values.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.op_Addition(Jitter.LinearMath.JMatrix,Jitter.LinearMath.JMatrix)">
            <summary>
            Adds two matrices.
            </summary>
            <param name="value1">The first matrix.</param>
            <param name="value2">The second matrix.</param>
            <returns>The sum of both values.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.op_Subtraction(Jitter.LinearMath.JMatrix,Jitter.LinearMath.JMatrix)">
            <summary>
            Subtracts two matrices.
            </summary>
            <param name="value1">The first matrix.</param>
            <param name="value2">The second matrix.</param>
            <returns>The difference of both values.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.CreateFromAxisAngle(Jitter.LinearMath.JVector@,System.Single,Jitter.LinearMath.JMatrix@)">
            <summary>
            Creates a matrix which rotates around the given axis by the given angle.
            </summary>
            <param name="axis">The axis.</param>
            <param name="angle">The angle.</param>
            <param name="result">The resulting rotation matrix</param>
        </member>
        <member name="M:Jitter.LinearMath.JMatrix.CreateFromAxisAngle(Jitter.LinearMath.JVector,System.Single)">
            <summary>
            Creates a matrix which rotates around the given axis by the given angle.
            </summary>
            <param name="axis">The axis.</param>
            <param name="angle">The angle.</param>
            <returns>The resulting rotation matrix</returns>
        </member>
        <member name="T:Jitter.LinearMath.JQuaternion">
            <summary>
            A Quaternion representing an orientation. Member of the math 
            namespace, so every method has it's 'by reference' equivalent
            to speed up time critical math operations.
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JQuaternion.X">
            <summary>The X component of the quaternion.</summary>
        </member>
        <member name="F:Jitter.LinearMath.JQuaternion.Y">
            <summary>The Y component of the quaternion.</summary>
        </member>
        <member name="F:Jitter.LinearMath.JQuaternion.Z">
            <summary>The Z component of the quaternion.</summary>
        </member>
        <member name="F:Jitter.LinearMath.JQuaternion.W">
            <summary>The W component of the quaternion.</summary>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the JQuaternion structure.
            </summary>
            <param name="x">The X component of the quaternion.</param>
            <param name="y">The Y component of the quaternion.</param>
            <param name="z">The Z component of the quaternion.</param>
            <param name="w">The W component of the quaternion.</param>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.Add(Jitter.LinearMath.JQuaternion,Jitter.LinearMath.JQuaternion)">
            <summary>
            Quaternions are added.
            </summary>
            <param name="quaternion1">The first quaternion.</param>
            <param name="quaternion2">The second quaternion.</param>
            <returns>The sum of both quaternions.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.Add(Jitter.LinearMath.JQuaternion@,Jitter.LinearMath.JQuaternion@,Jitter.LinearMath.JQuaternion@)">
            <summary>
            Quaternions are added.
            </summary>
            <param name="quaternion1">The first quaternion.</param>
            <param name="quaternion2">The second quaternion.</param>
            <param name="result">The sum of both quaternions.</param>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.Subtract(Jitter.LinearMath.JQuaternion,Jitter.LinearMath.JQuaternion)">
            <summary>
            Quaternions are subtracted.
            </summary>
            <param name="quaternion1">The first quaternion.</param>
            <param name="quaternion2">The second quaternion.</param>
            <returns>The difference of both quaternions.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.Subtract(Jitter.LinearMath.JQuaternion@,Jitter.LinearMath.JQuaternion@,Jitter.LinearMath.JQuaternion@)">
            <summary>
            Quaternions are subtracted.
            </summary>
            <param name="quaternion1">The first quaternion.</param>
            <param name="quaternion2">The second quaternion.</param>
            <param name="result">The difference of both quaternions.</param>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.Multiply(Jitter.LinearMath.JQuaternion,Jitter.LinearMath.JQuaternion)">
            <summary>
            Multiply two quaternions.
            </summary>
            <param name="quaternion1">The first quaternion.</param>
            <param name="quaternion2">The second quaternion.</param>
            <returns>The product of both quaternions.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.Multiply(Jitter.LinearMath.JQuaternion@,Jitter.LinearMath.JQuaternion@,Jitter.LinearMath.JQuaternion@)">
            <summary>
            Multiply two quaternions.
            </summary>
            <param name="quaternion1">The first quaternion.</param>
            <param name="quaternion2">The second quaternion.</param>
            <param name="result">The product of both quaternions.</param>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.Multiply(Jitter.LinearMath.JQuaternion,System.Single)">
            <summary>
            Scale a quaternion
            </summary>
            <param name="quaternion1">The quaternion to scale.</param>
            <param name="scaleFactor">Scale factor.</param>
            <returns>The scaled quaternion.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.Multiply(Jitter.LinearMath.JQuaternion@,System.Single,Jitter.LinearMath.JQuaternion@)">
            <summary>
            Scale a quaternion
            </summary>
            <param name="quaternion1">The quaternion to scale.</param>
            <param name="scaleFactor">Scale factor.</param>
            <param name="result">The scaled quaternion.</param>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.Normalize">
            <summary>
            Sets the length of the quaternion to one.
            </summary>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.CreateFromMatrix(Jitter.LinearMath.JMatrix)">
            <summary>
            Creates a quaternion from a matrix.
            </summary>
            <param name="matrix">A matrix representing an orientation.</param>
            <returns>JQuaternion representing an orientation.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.CreateFromMatrix(Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JQuaternion@)">
            <summary>
            Creates a quaternion from a matrix.
            </summary>
            <param name="matrix">A matrix representing an orientation.</param>
            <param name="result">JQuaternion representing an orientation.</param>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.op_Multiply(Jitter.LinearMath.JQuaternion,Jitter.LinearMath.JQuaternion)">
            <summary>
            Multiply two quaternions.
            </summary>
            <param name="value1">The first quaternion.</param>
            <param name="value2">The second quaternion.</param>
            <returns>The product of both quaternions.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.op_Addition(Jitter.LinearMath.JQuaternion,Jitter.LinearMath.JQuaternion)">
            <summary>
            Add two quaternions.
            </summary>
            <param name="value1">The first quaternion.</param>
            <param name="value2">The second quaternion.</param>
            <returns>The sum of both quaternions.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JQuaternion.op_Subtraction(Jitter.LinearMath.JQuaternion,Jitter.LinearMath.JQuaternion)">
            <summary>
            Subtract two quaternions.
            </summary>
            <param name="value1">The first quaternion.</param>
            <param name="value2">The second quaternion.</param>
            <returns>The difference of both quaternions.</returns>
        </member>
        <member name="T:Jitter.LinearMath.JVector">
            <summary>
            A vector structure. Member of the math 
            namespace, so every method has it's 'by reference' equivalent
            to speed up time critical math operations.
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.X">
            <summary>The X component of the vector.</summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.Y">
            <summary>The Y component of the vector.</summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.Z">
            <summary>The Z component of the vector.</summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.Zero">
            <summary>
            A vector with components (0,0,0);
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.Left">
            <summary>
            A vector with components (1,0,0);
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.Right">
            <summary>
            A vector with components (-1,0,0);
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.Up">
            <summary>
            A vector with components (0,1,0);
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.Down">
            <summary>
            A vector with components (0,-1,0);
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.Backward">
            <summary>
            A vector with components (0,0,1);
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.Forward">
            <summary>
            A vector with components (0,0,-1);
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.One">
            <summary>
            A vector with components (1,1,1);
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.MinValue">
            <summary>
            A vector with components 
            (float.MinValue,float.MinValue,float.MinValue);
            </summary>
        </member>
        <member name="F:Jitter.LinearMath.JVector.MaxValue">
            <summary>
            A vector with components 
            (float.MaxValue,float.MaxValue,float.MaxValue);
            </summary>
        </member>
        <member name="M:Jitter.LinearMath.JVector.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Constructor initializing a new instance of the structure
            </summary>
            <param name="x">The X component of the vector.</param>
            <param name="y">The Y component of the vector.</param>
            <param name="z">The Z component of the vector.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Set(System.Single,System.Single,System.Single)">
            <summary>
            Sets all vector component to specific values.
            </summary>
            <param name="x">The X component of the vector.</param>
            <param name="y">The Y component of the vector.</param>
            <param name="z">The Z component of the vector.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.#ctor(System.Single)">
            <summary>
            Constructor initializing a new instance of the structure
            </summary>
            <param name="xyz">All components of the vector are set to xyz</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.ToString">
            <summary>
            Builds a string from the JVector.
            </summary>
            <returns>A string containing all three components.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Equals(System.Object)">
            <summary>
            Tests if an object is equal to this vector.
            </summary>
            <param name="obj">The object to test.</param>
            <returns>Returns true if they are euqal, otherwise false.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.op_Equality(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Tests if two JVector are equal.
            </summary>
            <param name="value1">The first value.</param>
            <param name="value2">The second value.</param>
            <returns>Returns true if both values are equal, otherwise false.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.op_Inequality(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Tests if two JVector are not equal.
            </summary>
            <param name="value1">The first value.</param>
            <param name="value2">The second value.</param>
            <returns>Returns false if both values are equal, otherwise true.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Min(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Gets a vector with the minimum x,y and z values of both vectors.
            </summary>
            <param name="value1">The first value.</param>
            <param name="value2">The second value.</param>
            <returns>A vector with the minimum x,y and z values of both vectors.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Min(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
             ets a vector with the minimum x,y and z values of both vectors.
            </summary>
            <param name="value1">The first value.</param>
            <param name="value2">The second value.</param>
            <param name="result">A vector with the minimum x,y and z values of both vectors.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Max(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Gets a vector with the maximum x,y and z values of both vectors.
            </summary>
            <param name="value1">The first value.</param>
            <param name="value2">The second value.</param>
            <returns>A vector with the maximum x,y and z values of both vectors.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Max(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            Gets a vector with the maximum x,y and z values of both vectors.
            </summary>
            <param name="value1">The first value.</param>
            <param name="value2">The second value.</param>
            <param name="result">A vector with the maximum x,y and z values of both vectors.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.MakeZero">
            <summary>
            Sets the length of the vector to zero.
            </summary>
        </member>
        <member name="M:Jitter.LinearMath.JVector.IsZero">
            <summary>
            Checks if the length of the vector is zero.
            </summary>
            <returns>Returns true if the vector is zero, otherwise false.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.IsNearlyZero">
            <summary>
            Checks if the length of the vector is nearly zero.
            </summary>
            <returns>Returns true if the vector is nearly zero, otherwise false.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Transform(Jitter.LinearMath.JVector,Jitter.LinearMath.JMatrix)">
            <summary>
            Transforms a vector by the given matrix.
            </summary>
            <param name="position">The vector to transform.</param>
            <param name="matrix">The transform matrix.</param>
            <returns>The transformed vector.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Transform(Jitter.LinearMath.JVector@,Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JVector@)">
            <summary>
            Transforms a vector by the given matrix.
            </summary>
            <param name="position">The vector to transform.</param>
            <param name="matrix">The transform matrix.</param>
            <param name="result">The transformed vector.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.TransposedTransform(Jitter.LinearMath.JVector@,Jitter.LinearMath.JMatrix@,Jitter.LinearMath.JVector@)">
            <summary>
            Transforms a vector by the transposed of the given Matrix.
            </summary>
            <param name="position">The vector to transform.</param>
            <param name="matrix">The transform matrix.</param>
            <param name="result">The transformed vector.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Dot(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Calculates the dot product of two vectors.
            </summary>
            <param name="vector1">The first vector.</param>
            <param name="vector2">The second vector.</param>
            <returns>Returns the dot product of both vectors.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Dot(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            Calculates the dot product of both vectors.
            </summary>
            <param name="vector1">The first vector.</param>
            <param name="vector2">The second vector.</param>
            <returns>Returns the dot product of both vectors.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Add(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Adds two vectors.
            </summary>
            <param name="value1">The first vector.</param>
            <param name="value2">The second vector.</param>
            <returns>The sum of both vectors.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Add(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            Adds to vectors.
            </summary>
            <param name="value1">The first vector.</param>
            <param name="value2">The second vector.</param>
            <param name="result">The sum of both vectors.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Subtract(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Subtracts two vectors.
            </summary>
            <param name="value1">The first vector.</param>
            <param name="value2">The second vector.</param>
            <returns>The difference of both vectors.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Subtract(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            Subtracts to vectors.
            </summary>
            <param name="value1">The first vector.</param>
            <param name="value2">The second vector.</param>
            <param name="result">The difference of both vectors.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Cross(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            The cross product of two vectors.
            </summary>
            <param name="vector1">The first vector.</param>
            <param name="vector2">The second vector.</param>
            <returns>The cross product of both vectors.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Cross(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            The cross product of two vectors.
            </summary>
            <param name="vector1">The first vector.</param>
            <param name="vector2">The second vector.</param>
            <param name="result">The cross product of both vectors.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.GetHashCode">
            <summary>
            Gets the hashcode of the vector.
            </summary>
            <returns>Returns the hashcode of the vector.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Negate">
            <summary>
            Inverses the direction of the vector.
            </summary>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Negate(Jitter.LinearMath.JVector)">
            <summary>
            Inverses the direction of a vector.
            </summary>
            <param name="value">The vector to inverse.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Negate(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            Inverses the direction of a vector.
            </summary>
            <param name="value">The vector to inverse.</param>
            <param name="result">The negated vector.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Normalize(Jitter.LinearMath.JVector)">
            <summary>
            Normalizes the given vector.
            </summary>
            <param name="value">The vector which should be normalized.</param>
            <returns>A normalized vector.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Normalize">
            <summary>
            Normalizes this vector.
            </summary>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Normalize(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            Normalizes the given vector.
            </summary>
            <param name="value">The vector which should be normalized.</param>
            <param name="result">A normalized vector.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.LengthSquared">
            <summary>
            Gets the squared length of the vector.
            </summary>
            <returns>Returns the squared length of the vector.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Length">
            <summary>
            Gets the length of the vector.
            </summary>
            <returns>Returns the length of the vector.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Swap(Jitter.LinearMath.JVector@,Jitter.LinearMath.JVector@)">
            <summary>
            Swaps the components of both vectors.
            </summary>
            <param name="vector1">The first vector to swap with the second.</param>
            <param name="vector2">The second vector to swap with the first.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Multiply(Jitter.LinearMath.JVector,System.Single)">
            <summary>
            Multiply a vector with a factor.
            </summary>
            <param name="value1">The vector to multiply.</param>
            <param name="scaleFactor">The scale factor.</param>
            <returns>Returns the multiplied vector.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.Multiply(Jitter.LinearMath.JVector@,System.Single,Jitter.LinearMath.JVector@)">
            <summary>
            Multiply a vector with a factor.
            </summary>
            <param name="value1">The vector to multiply.</param>
            <param name="scaleFactor">The scale factor.</param>
            <param name="result">Returns the multiplied vector.</param>
        </member>
        <member name="M:Jitter.LinearMath.JVector.op_Modulus(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Calculates the cross product of two vectors.
            </summary>
            <param name="value1">The first vector.</param>
            <param name="value2">The second vector.</param>
            <returns>Returns the cross product of both.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.op_Multiply(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Calculates the dot product of two vectors.
            </summary>
            <param name="value1">The first vector.</param>
            <param name="value2">The second vector.</param>
            <returns>Returns the dot product of both.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.op_Multiply(Jitter.LinearMath.JVector,System.Single)">
            <summary>
            Multiplies a vector by a scale factor.
            </summary>
            <param name="value1">The vector to scale.</param>
            <param name="value2">The scale factor.</param>
            <returns>Returns the scaled vector.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.op_Multiply(System.Single,Jitter.LinearMath.JVector)">
            <summary>
            Multiplies a vector by a scale factor.
            </summary>
            <param name="value2">The vector to scale.</param>
            <param name="value1">The scale factor.</param>
            <returns>Returns the scaled vector.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.op_Subtraction(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Subtracts two vectors.
            </summary>
            <param name="value1">The first vector.</param>
            <param name="value2">The second vector.</param>
            <returns>The difference of both vectors.</returns>
        </member>
        <member name="M:Jitter.LinearMath.JVector.op_Addition(Jitter.LinearMath.JVector,Jitter.LinearMath.JVector)">
            <summary>
            Adds two vectors.
            </summary>
            <param name="value1">The first vector.</param>
            <param name="value2">The second vector.</param>
            <returns>The sum of both vectors.</returns>
        </member>
        <member name="T:Jitter.ResourcePool`1">
            <summary>
            A thread safe resource pool.
            </summary>
            <typeparam name="T">The type of the object to cache. The type T must
            have a parameterless constructor.</typeparam>
        </member>
        <member name="M:Jitter.ResourcePool`1.#ctor">
            <summary>
            Creates a new instance of the ResourcePool class.
            </summary>
        </member>
        <member name="M:Jitter.ResourcePool`1.ResetResourcePool">
            <summary>
            Removes all cached resources.
            So they can get garbage collected.
            </summary>
        </member>
        <member name="M:Jitter.ResourcePool`1.GiveBack(`0)">
            <summary>
            Gives a resource back to the pool.
            </summary>
            <param name="obj">The resource to give back</param>
        </member>
        <member name="M:Jitter.ResourcePool`1.GetNew">
            <summary>
            Get a free resource.
            </summary>
            <returns>The free resource.</returns>
        </member>
        <member name="T:Jitter.ArrayResourcePool`1">
            <summary>
            A thread safe resource pool.
            </summary>
            <typeparam name="T">The type of the array of objects to cache. The type T must
            have a parameterless constructor.  Do not specify [].</typeparam>
        </member>
        <member name="F:Jitter.ArrayResourcePool`1.arrayLength">
            <summary>
            The length of each array object to be created in the pool.
            </summary>
        </member>
        <member name="M:Jitter.ArrayResourcePool`1.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the ResourcePool class.
            </summary>
        </member>
        <member name="M:Jitter.ArrayResourcePool`1.ResetResourcePool">
            <summary>
            Removes all cached resources.
            So they can get garbage collected.
            </summary>
        </member>
        <member name="M:Jitter.ArrayResourcePool`1.GiveBack(`0[])">
            <summary>
            Gives a resource back to the pool.
            </summary>
            <param name="obj">The resource to give back</param>
        </member>
        <member name="M:Jitter.ArrayResourcePool`1.GetNew">
            <summary>
            Get a free resource.
            </summary>
            <returns>The free resource.</returns>
        </member>
        <member name="T:Jitter.ThreadManager">
            <summary>
            Jitters ThreadManager class handles the internal multithreading of the
            engine.
            </summary>
        </member>
        <member name="P:Jitter.ThreadManager.ThreadCount">
            <summary>
            Get the number of threads used by the ThreadManager to execute
            tasks.
            </summary>
        </member>
        <member name="M:Jitter.ThreadManager.Execute">
            <summary>
            Executes all tasks previously added to the ThreadManager.
            The method finishes when all tasks are complete.
            </summary>
        </member>
        <member name="M:Jitter.ThreadManager.AddTask(System.Action{System.Object},System.Object)">
            <summary>
            Adds a task to the ThreadManager. The task and the parameter
            is added to an internal list. Call <see cref="M:Jitter.ThreadManager.Execute"/>
            to execute and remove the tasks from the internal list.
            </summary>
            <param name="task"></param>
            <param name="param"></param>
        </member>
        <member name="T:Jitter.World">
            <summary>
            This class brings 'dynamics' and 'collisions' together. It handles
            all bodies and constraints.
            </summary>
        </member>
        <member name="P:Jitter.World.ArbiterMap">
            <summary>
            Holds a list of <see cref="T:Jitter.Dynamics.Arbiter"/>. All currently
            active arbiter in the <see cref="T:Jitter.World"/> are stored in this map.
            </summary>
        </member>
        <member name="P:Jitter.World.Islands">
            <summary>
            Gets a read only collection of the <see cref="T:Jitter.Collision.CollisionIsland"/> objects managed by
            this class.
            </summary>
        </member>
        <member name="M:Jitter.World.#ctor(Jitter.Collision.CollisionSystem)">
            <summary>
            Create a new instance of the <see cref="T:Jitter.World"/> class.
            </summary>
            <param name="collision">The collisionSystem which is used to detect
            collisions. See for example: <see cref="T:Jitter.Collision.CollisionSystemSAP"/>
            or <see cref="T:Jitter.Collision.CollisionSystemBrute"/>.
            </param>
        </member>
        <member name="P:Jitter.World.CollisionSystem">
            <summary>
            Gets the <see cref="P:Jitter.World.CollisionSystem"/> used
            to detect collisions.
            </summary>
        </member>
        <member name="M:Jitter.World.ResetResourcePools">
            <summary>
            In Jitter many objects get added to stacks after they were used.
            If a new object is needed the old object gets removed from the stack
            and is reused. This saves some time and also garbage collections.
            Calling this method removes all cached objects from all
            stacks.
            </summary>
        </member>
        <member name="M:Jitter.World.Clear">
            <summary>
            Removes all objects from the world and removes all memory cached objects.
            </summary>
        </member>
        <member name="P:Jitter.World.Gravity">
            <summary>
            Gets or sets the gravity in this <see cref="T:Jitter.World"/>. The default gravity
            is (0,-9.81,0)
            </summary>
        </member>
        <member name="P:Jitter.World.AllowDeactivation">
            <summary>
            Global sets or gets if a body is able to be temporarily deactivated by the engine to
            safe computation time. Use <see cref="M:Jitter.World.SetInactivityThreshold(System.Single,System.Single,System.Single)"/> to set parameters
            of the deactivation process.
            </summary>
        </member>
        <member name="M:Jitter.World.SetDampingFactors(System.Single,System.Single)">
            <summary>
            Every computation <see cref="M:Jitter.World.Step(System.Single,System.Boolean)"/> the angular and linear velocity 
            of a <see cref="T:Jitter.Dynamics.RigidBody"/> gets multiplied by this value.
            </summary>
            <param name="angularDamping">The factor multiplied with the angular velocity.
            The default value is 0.85.</param>
            <param name="linearDamping">The factor multiplied with the linear velocity.
            The default value is 0.85</param>
        </member>
        <member name="M:Jitter.World.SetInactivityThreshold(System.Single,System.Single,System.Single)">
            <summary>
            Sets parameters for the <see cref="T:Jitter.Dynamics.RigidBody"/> deactivation process.
            If the bodies angular velocity is less than the angular velocity threshold
            and its linear velocity is lower then the linear velocity threshold for a 
            specific time the body gets deactivated. A body can be reactivated by setting
            <see cref="P:Jitter.Dynamics.RigidBody.IsActive"/> to true. A body gets also automatically
            reactivated if another moving object hits it or the <see cref="T:Jitter.Collision.CollisionIsland"/>
            the object is in gets activated.
            </summary>
            <param name="angularVelocity">The threshold value for the angular velocity. The default value
            is 0.1.</param>
            <param name="linearVelocity">The threshold value for the linear velocity. The default value
            is 0.1</param>
            <param name="time">The threshold value for the time in seconds. The default value is 2.</param>
        </member>
        <member name="M:Jitter.World.SetIterations(System.Int32,System.Int32)">
            <summary>
            Jitter uses an iterativ approach to solve collisions and contacts. You can set the number of
            iterations Jitter should do. In general the more iterations the more stable a simulation gets
            but also costs computation time.
            </summary>
            <param name="iterations">The number of contact iterations. Default value 10.</param>
            <param name="smallIterations">The number of contact iteration used for smaller (two and three constraint) systems. Default value 4.</param>
            <remarks>The number of iterations for collision and contact should be between 3 - 30.
            More iterations means more stability and also a longer calculation time.</remarks>
        </member>
        <member name="M:Jitter.World.RemoveBody(Jitter.Dynamics.RigidBody)">
            <summary>
            Removes a <see cref="T:Jitter.Dynamics.RigidBody"/> from the world.
            </summary>
            <param name="body">The body which should be removed.</param>
            <returns>Returns false if the body could not be removed from the world.</returns>
        </member>
        <member name="M:Jitter.World.AddBody(Jitter.Dynamics.RigidBody)">
            <summary>
            Adds a <see cref="T:Jitter.Dynamics.RigidBody"/> to the world.
            </summary>
            <param name="body">The body which should be added.</param>
        </member>
        <member name="M:Jitter.World.RemoveConstraint(Jitter.Dynamics.Constraints.Constraint)">
            <summary>
            Add a <see cref="T:Jitter.Dynamics.Constraints.Constraint"/> to the world. Fast, O(1).
            </summary>
            <param name="constraint">The constraint which should be added.</param>
            <returns>True if the constraint was successfully removed.</returns>
        </member>
        <member name="M:Jitter.World.AddConstraint(Jitter.Dynamics.Constraints.Constraint)">
            <summary>
            Add a <see cref="T:Jitter.Dynamics.Constraints.Constraint"/> to the world.
            </summary>
            <param name="constraint">The constraint which should be removed.</param>
        </member>
        <member name="F:Jitter.World.debugTimes">
            <summary>
            Time in ms for every part of the <see cref="M:Jitter.World.Step(System.Single,System.Boolean)"/> method.
            </summary>
            <example>int time = DebugTimes[(int)DebugType.CollisionDetect] gives
            the amount of time spent on collision detection during the last <see cref="M:Jitter.World.Step(System.Single,System.Boolean)"/>.
            </example>
        </member>
        <member name="M:Jitter.World.Step(System.Single,System.Boolean)">
            <summary>
            Integrates the whole world a timestep further in time.
            </summary>
            <param name="timestep">The timestep in seconds. 
            It should be small as possible to keep the simulation stable.
            The physics simulation shouldn't run slower than 60fps.
            (timestep=1/60).</param>
            <param name="multithread">If true the engine uses several threads to
            integrate the world. This is faster on multicore CPUs.</param>
        </member>
        <member name="M:Jitter.World.Step(System.Single,System.Boolean,System.Single,System.Int32)">
            <summary>
            Integrates the whole world several fixed timestep further in time.
            </summary>
            <param name="totalTime">The time to integrate.</param>
            <param name="timestep">The timestep in seconds. 
            It should be small as possible to keep the simulation stable.
            The physics simulation shouldn't run slower than 60fps.
            (timestep=1/60).</param>
            <param name="multithread">If true the engine uses several threads to
            integrate the world. This is faster on multicore CPUs.</param>
            <param name="maxSteps">The maximum number of substeps. After that Jitter gives up
            to keep up with the given totalTime.</param>
        </member>
    </members>
</doc>
